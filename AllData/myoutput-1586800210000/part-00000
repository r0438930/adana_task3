{"title_page": "Julia (programming language)", "text_new": "{{Use dmy dates|date=October 2015}}\n{{Infobox programming language\n| name = Julia\n| logo = Julia Programming Language Logo.svg\n| logo caption = \n| screenshot = <!-- filename is enough -->\n| screenshot caption = \n| paradigm = [[multi-paradigm programming language|Multi-paradigm]]: [[multiple dispatch]] (core), [[procedural programming|procedural]], [[functional programming|functional]], [[metaprogramming|meta]], [[multistaged programming|multistaged]]<ref>{{cite web |url=https://medium.com/@acidflask/smoothing-data-with-julia-s-generated-functions-c80e240e05f3#.615wk3dle |title=Smoothing data with Julia's @generated functions |quote=Julia's generated functions are closely related to the multistaged programming (MSP) paradigm popularized by Taha and Sheard, which generalizes the compile time/run time stages of program execution by allowing for multiple stages of delayed code execution. |date=5 November 2015 |accessdate=9 December 2015}}</ref>\n| released = {{Start date and age|2012}}<ref name=\"announcement\"/>\n| designer = Jeff Bezanson, [[Alan Edelman]], [[Stefan Karpinski]], [[Viral B. Shah]]\n| developer = Jeff Bezanson, [[Stefan Karpinski]], [[Viral B. Shah]], and other contributors<ref name=\"license\">{{cite web\n  | url = https://github.com/JuliaLang/julia/blob/master/LICENSE.md\n  | title = LICENSE.md\n  | publisher = [[GitHub]]\n  }}</ref><ref>{{cite web\n  | url = https://github.com/JuliaLang/julia/graphs/contributors\n  | title = Contributors to JuliaLang/julia\n  | publisher = [[GitHub]]\n  }}</ref>\n| latest release version = 1.4.0<ref>{{cite web|author= |url=https://github.com/JuliaLang/julia/releases/tag/v1.4.0 |title=v1.4.0 |website=Github.com |date=2020-03-21 |accessdate=2020-03-21}}</ref>\n| latest release date = {{Start date and age|2020|03|21|df=yes}}\n| latest preview version = <!--1.4.0-rc2<ref>{{cite web|author= |url=https://github.com/JuliaLang/julia/releases/tag/v1.4.0-rc2 |title=v1.4.0-rc2 |website=Github.com |date=2020-02-24 |accessdate=2020-02-24}}</ref>\n| latest preview date = {{Start date and age|2020|02|24|df=yes}} / --> 1.5.0-DEV with daily updates (and 1.4.1 worked on<ref>https://github.com/JuliaLang/julia/pull/35229</ref>)\n| typing = [[dynamic programming language|Dynamic]], [[nominal type system|nominative]], [[parametric polymorphism|parametric]], [[optional typing|optional]]\n| implementations = \n| dialects = \n| influenced by = {{Flatlist}}\n* [[C (programming language)|C]]<ref name=\"announcement\"/>\n* [[Lisp (programming language)|Lisp]]<ref name=\"announcement\"/><!--only the parser implemented by femtolisp, a [[Scheme (programming language)|Scheme]]-like implementation (see: \"unsupported\" \"julia --lisp\" that invokes it, but its only influence on the language/syntax \u2013 Lisp-like macros? Maybe not even Lisp's CLOS \"multimethods\"? as Dylan with \"multiple dispatch\" was cut from the list-->\n* [[Lua (programming language)|Lua]]<ref name=\"Introduction\">{{Cite web|url=https://docs.julialang.org/en/v1/|title=<!--Chapter: Introduction under --> Home \u00b7 The Julia Language|website=docs.julialang.org|language=en|access-date=2018-08-15}}</ref>\n* [[Mathematica]]<ref name=\"announcement\"/> (strictly its [[Wolfram Language]]<ref name=\"announcement\"/><ref>{{cite web |url=https://fatiherikli.github.io/programming-language-network/ |title=Programming Language Network |publisher=GitHub |accessdate=6 December 2016}}</ref>)\n* [[MATLAB]]<ref name=\"announcement\"/>\n* [[Perl]]<ref name=\"Introduction\"/>\n* [[Python (programming language)|Python]]<ref name=\"Introduction\"/>\n* [[R (programming language)|R]]<ref name=\"announcement\"/>\n* [[Ruby (programming language)|Ruby]]<ref name=\"Introduction\"/>\n* [[Scheme (programming language)|Scheme]]<ref name=\"JuliaCon2016\">{{cite web |url=http://www.juliacon.org |title=JuliaCon 2016 |publisher=JuliaCon |quote=\"He has co-designed the programming language Scheme, which has greatly influenced the design of Julia\"|accessdate=6 December 2016}}</ref>\n{{endflatlist}}\n| influenced = \n| programming language = Julia, [[C (programming language)|C]],<!--\"Remove when C11 is required for C code\" https://github.com/JuliaLang/julia/search?utf8=%E2%9C%93&q=C11&type=\n\n\"These roughly follows the c11/c++11 memory model [..] The only exception is the GC safepoint and GC state transitions [..] We use the compiler intrinsics to implement a similar API to the c11/c++11\" https://github.com/JuliaLang/julia/blob/44f3d7c921cbe50105a54258db2febb65a4b9d44/src/julia_threads.h\n--> [[C++]], [[Scheme (programming language)|Scheme]], [[LLVM]]<ref name=\"JuliaHome\">{{cite web |url=https://julialang.org/ |title=Julia |author=<!--Staff writer(s); no by-line.--> |date=<!--None listed.--> |website=Julia |publisher=[[NumFocus]] project |access-date=9 December 2016 |quote=Julia's Base library, largely written in Julia itself, also integrates mature, best-of-breed open source C and Fortran libraries for ...}}</ref>\n| platform = Tier&nbsp;1: [[x86-64]], [[IA-32]], [[CUDA]]<br />Tier&nbsp;2: [[ARM architecture|ARM]] (both 32- and 64-bit)<br /> Tier&nbsp;3: [[PowerPC]]<br />Also has web browser support (for [[JavaScript]] and [[WebAssembly]])<ref name=\"WebAssembly\"/> and works in [[Android (operating system)|Android]].\n| operating system = [[Linux]], [[macOS]], [[Microsoft Windows|Windows]] and <!-- no longer just community support for --> [[FreeBSD]]\n| license = [[MIT License|MIT]] (core),<ref name=\"license\"/><!--for core language while, by default, \"the environment, which consists of the language, user interfaces, and libraries, is under the GPL\"--> [[General Public Licence|GPL v2]];<ref name=\"JuliaHome\" /><ref>{{cite newsgroup|url=https://groups.google.com/forum/#!topic/julia-users/v4OjEK7azBs |title=Non-GPL Julia? |website=Groups.google.com |date= |accessdate=2017-05-31}}</ref><!--as some few libraries used by the standard library (that can be excluded) are [[copyleft]]--> a [[makefile]] option omits GPL libraries<ref>{{cite web |url=https://github.com/JuliaLang/julia/pull/10870 |title=Introduce USE_GPL_LIBS Makefile flag to build Julia without GPL libraries |quote=Note that this commit does not remove GPL utilities such as git and busybox that are included in the Julia binary installers on Mac and Windows.<!--dropped as of 0.5 then only libgit2--> It allows building from source with no GPL library dependencies.}}</ref>\n| file ext = .jl\n| website = {{Official website|https://JuliaLang.org|name=JuliaLang.org}}\n}}\n\n'''Julia''' is a [[high-level programming language|high-level]], high-performance, dynamic [[programming language]]. While it is a general purpose language and can be used to write any application, many of its features are well-suited for high-performance [[numerical analysis]] and [[computational science]].<ref>{{cite web\n  | date       = 15 October 2012\n  | last       = Bryant\n  | first      = Avi\n  | title      = Matlab, R, and Julia: Languages for data analysis\n  | url        = https://strata.oreilly.com/2012/10/matlab-r-julia-languages-for-data-analysis.html\n  | archiveurl = https://web.archive.org/web/20140426110631/https://strata.oreilly.com/2012/10/matlab-r-julia-languages-for-data-analysis.html\n  | archivedate= 2014-04-26\n  | publisher  = O'Reilly Strata\n  }}</ref><ref>{{cite web\n  | date       = 23 August 2015\n  | last       = Singh\n  | first      = Vicky\n  | title      = Julia Programming Language \u2013 A True Python Alternative\n  | url        = https://www.technotification.com/2018/08/julia-programming-language.html\n  | publisher  = Technotification\n  }}</ref><ref>{{cite magazine\n  | last       = Krill\n  | first      = Paul\n  | title      = New Julia language seeks to be the C for scientists\n  | url        = https://www.infoworld.com/d/application-development/new-julia-language-seeks-be-the-c-scientists-190818\n  | magazine   = InfoWorld\n  | date       = 18 April 2012\n  }}</ref><ref>{{cite magazine\n  | last       = Finley\n  | first      = Klint\n  | title      = Out in the Open: Man Creates One Programming Language to Rule Them All\n  | url        = https://www.wired.com/2014/02/julia/\n  | magazine   = Wired\n  | date       = 3 February 2014\n  }}</ref>\n\nDistinctive aspects of Julia's design include a type system with [[parametric polymorphism]] in a [[dynamic programming language]]; with [[multiple dispatch]] as its core [[programming paradigm]]. Julia supports [[Concurrent computing|concurrent]], (composable) [[parallel computing|parallel]] and [[distributed computing]] (with or without using [[Message Passing Interface|MPI]]<ref>{{cite web|title=GitHub - JuliaParallel/MPI.jl: MPI wrappers for Julia.|url=https://github.com/JuliaParallel/MPI.jl|publisher=Parallel Julia|access-date=2019-09-22}}</ref> and/or the built-in corresponding<ref>{{Cite web|url=https://discourse.julialang.org/t/questions-about-getting-started-with-parallel-computing/25341/3?u=palli|title=Questions about getting started with parallel computing|date=2019-06-16|website=JuliaLang|language=en-US|access-date=2019-10-08}}</ref> to \"[[OpenMP]]-style\" threads<ref>{{Cite web|url=https://discourse.julialang.org/t/julia-and-concurrency/25556/2|title=Julia and Concurrency|date=2019-06-24|website=JuliaLang|language=en-US|access-date=2019-09-22}}</ref>), and [[foreign function interface|direct calling]] of [[C (programming language)|C]] and [[Fortran]] libraries without [[adapter pattern#gluecode|glue code]]. A [[Just-in-time compilation|just-in-time]] compiler that is referred to as \"just-[[Ahead-of-time compilation|ahead-of-time]]\"<ref>{{cite web |last1=Fischer |first1=Keno |last2=Nash |first2=Jameson |title=Growing a Compiler - Getting to Machine Learning from a General Purpose Compiler |url=https://juliacomputing.com/blog/2019/02/19/growing-a-compiler.html |website=Julia Computing Blog |accessdate=11 April 2019}}</ref> in the Julia community is used.\n\nJulia is [[garbage collection (computer science)|garbage-collected]],<ref>{{cite newsgroup|url=https://groups.google.com/forum/#!topic/julia-users/6_XvoLBzN60 |title=Suspending Garbage Collection for Performance...good idea or bad idea? |website=Groups.google.com |date= |accessdate=2017-05-31}}</ref> uses [[eager evaluation]], and includes efficient libraries for [[floating-point]] calculations, [[linear algebra]], [[random number generation]], and [[regular expression]] matching. Many libraries are available, including some (e.g., for [[fast Fourier transform]]s) that were previously bundled with Julia and are now separate.<ref>now available with <code>using [[FFTW]]</code> in current versions (That dependency, is one of many which, was moved out of the standard library to a package because it is GPL licensed, and thus is not included in Julia 1.0 by default.) {{Cite web|url=https://github.com/JuliaLang/julia/pull/21956|title=Remove the FFTW bindings from Base by ararslan \u00b7 Pull Request #21956 \u00b7 JuliaLang/julia|website=GitHub|language=en|access-date=2018-03-01}}</ref>\n\nTools available for Julia include, not just many widely used editors, such as [[Vim (text editor)|Vim]] and [[Emacs]], but also [[integrated development environment|IDEs]] (e.g. Juno, and Microsoft's [[Visual Studio Code]], with [[Plug-in (computing)|extensions]] adding Julia support, both providing debugging support); with integrated tools, e.g. a [[lint (software)|linter]],<ref>{{Cite web|url=https://discourse.julialang.org/t/ann-linter-julia-plugin-for-atom-juno/2118|title=ANN: linter-julia plugin for Atom / Juno|date=2017-02-15|website=JuliaLang|language=en|access-date=2019-04-10}}</ref> [[profiling (computer programming)|profiler]] (and flame graph support available<ref>{{Citation|last=Holy|first=Tim|title=GitHub - timholy/ProfileView.jl: Visualization of Julia profiling data.|date=2019-09-13|url=https://github.com/timholy/ProfileView.jl|access-date=2019-09-22}}</ref><ref>{{Citation|last=Gregg|first=Brendan|title=GitHub - brendangregg/FlameGraph: Stack trace visualizer.|date=2019-09-20|url=https://github.com/brendangregg/FlameGraph|access-date=2019-09-22}}</ref> for the built-in one), debugger,<ref>{{Cite web|url=https://julialang.org/blog/2019/03/debuggers|title=A Julia interpreter and debugger|website=julialang.org|access-date=2019-04-10}}</ref> and the Rebugger.jl package \"supports [[interactive programming|repeated-execution debugging]]\"{{Efn|<!--quote= --> [With Rebugger.jl] you can:\n* test different modifications to the code or arguments as many times as you want; you are never forced to exit \u201cdebug mode\u201d and save your file\n* run the same chosen block of code repeatedly (perhaps trying out different ways of fixing a bug) without needing to repeat any of the \u201csetup\u201d work that might have been necessary to get to some deeply nested method in the original call stack.<ref name=\"Rebugger\">{{Cite web|url=https://discourse.julialang.org/t/ann-rebugger-interactive-debugging-for-julia-0-7-1-0/13843|title=[ANN] Rebugger: interactive debugging for Julia 0.7/1.0|quote=<!--Better in the \"Efn\" footnote above?-->\n|date=2018-08-21|website=JuliaLang|language=en|access-date=2019-04-10}}</ref>}} and more.<ref>{{Cite web|url=https://timholy.github.io/Rebugger.jl/dev/|title=Home \u00b7 Rebugger.jl|website=timholy.github.io|access-date=2019-04-10}}</ref>\n\n==History==\nWork on Julia was started in 2009, by Jeff Bezanson, [[Stefan Karpinski]], [[Viral B. Shah]], and [[Alan Edelman]], who set out to create a free language that was both high-level and fast. On 14 February 2012, the team launched a website with a blog post explaining the language's mission.<ref>{{cite web|last1=Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman|title=Why We Created Julia|url=https://julialang.org/blog/2012/02/why-we-created-julia|website=JuliaLang.org|accessdate=5 June 2017}}</ref>  In an interview with InfoWorld in April 2012, Karpinski said of the name \"Julia\": \"There's no good reason, really. It just seemed like a pretty name.\"<ref>[[Stefan Karpinski]], [https://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html New Julia language seeks to be the C for scientists], [[InfoWorld]], 18 April 2012</ref> Bezanson said he chose the name on the recommendation of a friend.<ref>{{cite web |last1=Torre |first1=Charles |title=Stefan Karpinski and Jeff Bezanson on Julia |url=https://channel9.msdn.com/Blogs/Charles/Stefan-Karpinski-and-Jeff-Bezanson-Julia-Programming-Language |website=Channel 9 |publisher=MSDN |accessdate=4 December 2018}}</ref>\n\nSince the 2012 launch, the Julia community has grown, with over 13,000,000 downloads {{as of|2020|03|lc=y}} (and is used at more than 1,500 universities),<ref>{{Cite web|url=https://juliacomputing.com/|title=Julia Computing|website=juliacomputing.com||access-date=2020-04-05}}</ref><ref>{{Cite web|url=https://juliacomputing.com/blog/2019/11/07/november-newsletter.html|title=Newsletter November 2019|date=2019-11-07|website=juliacomputing.com|access-date=2019-11-29}}</ref><ref>{{Cite web|url=https://juliacomputing.com/blog/2019/01/04/january-newsletter.html |title=Julia Computing Newsletter, Growth Metrics|website=juliacomputing.com|access-date=2019-02-11}}</ref> The Official Julia Docker images, at [[Docker, Inc.|Docker Hub]], have seen over 4,000,000 downloads as of January 2019.<ref>{{Cite web|url=https://juliacomputing.com/blog/2019/01/04/january-newsletter.html|title=Newsletter January 2019|website=juliacomputing.com|date=4 January 2019|access-date=2019-08-20}}</ref><ref>https://hub.docker.com/_/julia</ref> The JuliaCon<ref>{{cite web|url=http://juliacon.org/ |title=JuliaCon website |website=juliacon.org |accessdate=2018-05-10}}</ref> [[academic conference]] for Julia users and developers has been held annually since 2014.\n\nVersion 0.3 was released in August 2014, version 0.4 in October 2015, version 0.5 in October 2016,<ref>[https://julialang.org/blog/ The Julia Blog]</ref> and version 0.6 in June 2017.<ref>https://julialang.org/blog/2017/06/julia-0.6-release</ref>  Both Julia 0.7 (a useful release for testing packages, and for knowing how to upgrade them for 1.0<ref>{{Cite web|url=https://discourse.julialang.org/t/what-is-julia-0-7-how-does-it-relate-to-1-0/9994|title=What is Julia 0.7? How does it relate to 1.0?|website=JuliaLang|language=en|access-date=2018-10-17}}</ref>) and version 1.0 were released on 8 August 2018. Work on Julia 0.7 was a \"huge undertaking\" (e.g., because of \"entirely new optimizer\"), and some changes were made to semantics, e.g. the [[iteration]] interface was simplified;<ref>{{Cite web|url=https://julialang.org/blog/2018/07/iterators-in-julia-0.7 |title=Writing Iterators in Julia 0.7 |authors=Eric Davies |website=julialang.org |access-date=2018-08-05}}</ref> and the syntax changed a little (with the syntax now stable, and same for 1.x and 0.7).\n\nThe release candidate for Julia 1.0 (Julia 1.0.0-rc1) was released on 7 August 2018, and the final version a day later (and by now, Julia 1.0.x are the oldest versions still supported, having [[long-term support]]; for at least a year). Julia 1.1 was released in January 2019 with, e.g., a new \"exception stack\" language feature. Bugfix releases are expected roughly monthly, for 1.4.x and 1.0.x and Julia 1.0.1 up to 1.0.5 have followed that schedule. Julia 1.2 was released in August 2019, and it has e.g. some built-in support for web browsers (for testing if running in [[JavaScript]] VM),<ref>{{Cite web|title=Sys.isjsvm([os])|date=2019-08-20|url=https://github.com/JuliaLang/julia/blob/75c10e435b2b9c947422ad38fa0b020595d3f747/base/sysinfo.jl#L401|quote=Predicate for testing if Julia is running in a JavaScript VM (JSVM), including e.g. a WebAssembly JavaScript embedding in a web browser.|publisher=The Julia Language|access-date=2019-08-20}}</ref> and Julia 1.4 in March 2020 (and with it Julia 1.3.x, 1.2.x and Julia 1.1.x releases are no longer maintained). Julia 1.3 added e.g. composable multi-threaded parallelism and a binary artifacts system for Julia packages.<ref>{{Cite web|url=https://julialang.org/blog/2019/11/artifacts|title=The Julia Language|others=Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al <!--|others=et al |authors5=et al-->|website=julialang.org|access-date=2019-12-13}}</ref> \n\nJulia 1.4 allowed better syntax for array indexing to handle e.g. [[zero-based_numbering#Usage_in_programming_languages|0-based]] arrays, with {{code|A[begin+1]}} for '''second''' element of array A.<ref>{{Cite web|url=https://github.com/JuliaLang/julia/pull/33946|title=support a[begin] for a[firstindex(a)] by stevengj \u00b7 Pull Request #33946 \u00b7 JuliaLang/julia|website=GitHub|language=en|access-date=2020-04-07}}</ref> It also changed the memory model.<ref>{{Cite web|url=https://github.com/JuliaLang/julia/pull/32448|title=For structs with all isbits or isbitsunion fields, allow them to be s<!--\u2026-->tored inline in arrays <!--by quinnj--> \u00b7 Pull Request #32448 \u00b7 JuliaLang/julia|author=quinnj|quote=I still keep running into problems that this causes internally because it was a breaking change that changes assumptions made by some users and inference/codegen.|website=GitHub|language=en|access-date=2020-04-07}}</ref>\n\nMost packages that work in Julia 1.0.x also work in 1.1.x or newer, enabled by the [[forward compatibility|forward compatible]] syntax guarantee. A major exception was, for interacting with non-Julia code, the JavaCall.jl package (however calling other languages, e.g. [[R (programming language)|R language]] works, with the package for R fixed<ref>{{Cite web|url=https://github.com/JuliaInterop/RCall.jl/pull/293|title=Fix for C stack checking issues on 1.1 by simonbyrne \u00b7 Pull Request #293 \u00b7 JuliaInterop/RCall.jl|website=GitHub|language=en|access-date=2019-08-10}}</ref>) to call Java, Scala etc. This was fixed by Java 11,<ref>{{Cite web|url=https://github.com/JuliaInterop/JavaCall.jl/issues/96#issuecomment-534178269|title=StackOverflowError in `JavaCall.init` for Julia 1.1.0 \u00b7 Issue #96 \u00b7 JuliaInterop/JavaCall.jl|website=GitHub|language=en|access-date=2019-10-21}}</ref> or alternatively to use those languages with Julia (on older JVM), for e.g. [[Java Database Connectivity|JDBC]].jl or [[Apache Spark]] (through Spark.jl), users could choose to stay with the LTS version of Julia.<ref>{{Cite web|url=https://github.com/JuliaLang/julia/issues/31104|title=JVM fails to load in 1.1 (JavaCall.jl) \u00b7 Issue #31104 \u00b7 JuliaLang/julia|quote=JeffBezanson modified the milestones: 1.3, 1.4|website=GitHub|language=en|access-date=2019-08-18}}</ref> <!--A milestone was set for a fix in Julia 1.4 (while there's already a workaround in Julia 1.3.0<ref>{{Cite web|url=https://github.com/JuliaLang/julia/commit/ae4e08c5581a077ea269a9bd5a351082104f6daf|title=add environment variable `JULIA_ALWAYS_COPY_STACKS` (#32885) \u00b7 JuliaLang/julia@ae4e08c|website=GitHub|language=en|access-date=2019-08-18}}</ref>), to support older Java, which has-->  Julia 1.4 had a milestone set for 15 December 2019 and for Julia 1.5 the due date is 15 April 2020. Milestones for Julia 2.0 (and later, e.g. 3.0) currently have no set due dates.<ref>{{Cite web|title=Milestones - JuliaLang/julia|url=https://github.com/JuliaLang/julia/milestones|publisher=The Julia Language|access-date=2019-12-13}}</ref>\n\n===Notable uses===\nJulia has attracted some high-profile users, from investment manager [[BlackRock]], which uses it for [[time-series analytics]], to the British insurer [[Aviva]], which uses it for [[risk calculations]]. In 2015, the [[Federal Reserve Bank of New York]] used Julia to make models of the United States economy, noting that the language made model estimation \"about 10 times faster\" than its previous [[MATLAB]] implementation. Julia's co-founders established Julia Computing in 2015 to provide paid support, training, and consulting services to clients, though Julia remains free to use. At the 2017 JuliaCon<ref>{{cite web|url=http://juliacon.org/2017/ |title=JuliaCon 2017 |website=juliacon.org |accessdate=2017-06-04}}</ref> conference, Jeffrey Regier, [[Keno Fischer]] and others announced<ref>{{cite web|last1=Fisher|first1=Keno|title=The Celeste Project|url=https://juliacon2017.sched.com/speaker/thecelesteproject|website=juliacon.org|accessdate=24 June 2017}}</ref> that the Celeste project<ref>{{Cite arXiv|last1=Regier|first1=Jeffrey|last2=Pamnany|first2=Kiran|last3=Giordano|first3=Ryan|last4=Thomas|first4=Rollin|last5=Schlegel|first5=David|last6=McAulife|first6=Jon|last7=Prabat|title=Learning an Astronomical Catalog of the Visible Universe through Scalable Bayesian Inference|eprint=1611.03404|class=cs.DC|year=2016}}</ref> used Julia to achieve \"peak performance of 1.54&nbsp;[[FLOPS|petaFLOPS]] using 1.3 million threads\"<ref>{{Cite press release|url=https://juliacomputing.com/press/2017/09/12/julia-joins-petaflop-club.html |title=Julia Joins Petaflop Club |date=12 September 2017 | first=Andrew |last=Claster |work=Julia Computing |quote=Celeste is written entirely in Julia, and the Celeste team loaded an aggregate of 178 terabytes of image data to produce the most accurate catalog of 188 million [[astronomical object]]s in just 14.6 minutes [..] a performance improvement of 1,000x in single-threaded execution.}}</ref> on 9300 <!-- on 9,300 (vs. 8192 Xeon cores\") possibly \"optional nVidia\" GPU cards of Cori are used (or not), unclear conflated with lower numbers? --> [[Knights Landing (microarchitecture)|Knights Landing]] (KNL) nodes of the [[Cray XC40#United States|Cori II (Cray XC40)]] supercomputer (then 6th fastest computer in the world).<ref>{{Cite web|url=https://twitter.com/Viral_B_Shah/status/930928375400751105|title=. @KenoFischer is speaking on Celeste in the @Intel theatre at @Supercomputing. 0.65M cores, 56 TB of data, Cori - world's 6th largest supecomputer.pic.twitter.com/21nLHo1qty|last=Shah|first=Viral B.|date=2017-11-15|website=@Viral_B_Shah|language=en|access-date=2019-09-15}}</ref> Julia thus joins C, C++, and Fortran as high-level languages in which petaFLOPS computations have been achieved.\n\nThree of the Julia co-creators are the recipients of the 2019 [[J. H. Wilkinson Prize for Numerical Software|James H. Wilkinson Prize for Numerical Software]] (awarded every four years) \"for the creation of Julia, an innovative environment for the creation of high-performance tools that enable the analysis and solution of computational science problems.\"<ref>{{Cite web|url=https://news.mit.edu/2018/julia-language-co-creators-win-james-wilkinson-prize-numerical-software-1226|title=Julia language co-creators win James H. Wilkinson Prize for Numerical Software|website=MIT News|access-date=2019-01-22}}</ref>  Also, Alan Edelman, professor of applied mathematics at MIT, has been selected to receive the 2019 IEEE Computer Society Sidney Fernbach Award \"for outstanding breakthroughs in high-performance computing, linear algebra, and computational science and for contributions to the Julia programming language.\"<ref>{{Cite press release|url=https://www.computer.org/press-room/2019-news/2019-ieee-fernbach-award-edelman|title=Alan Edelman of MIT Recognized with Prestigious 2019 IEEE Computer Society Sidney Fernbach Award {{!}} IEEE Computer Society|language=en-US|date=1 October 2019|access-date=2019-10-09}}</ref>\n\nJulia Computing and [[NVIDIA]] announce \"the availability of the Julia programming language as a pre-packaged container on the NVIDIA GPU Cloud (NGC) container registry\"<ref name=\"Julia_Nvidia\">{{Cite web|url=https://juliacomputing.com/blog/2019/12/03/nvidia-ngc-arm.html|title=Julia Computing and NVIDIA Bring Julia GPU Computing to Arm|date=2019-12-03|website=juliacomputing.com|access-date=2019-12-03}}</ref> with NVIDIA stating \"Easily Deploy Julia on x86 and Arm [..] Julia offers a package for a comprehensive HPC ecosystem covering machine learning, data science, various scientific domains and visualization.\"<ref>{{Cite web|url=https://blogs.nvidia.com/blog/2019/11/18/ngc-containers-arm/|title=NVIDIA Expands Support for Arm with HPC, AI, Visualization Containers on NGC {{!}} NVIDIA Blog|last=Patel|first=Chintan|date=2019-11-19|website=The Official NVIDIA Blog|language=en-US|access-date=2019-12-03}}</ref>\n\nAdditionally, \"Julia was selected by the [https://clima.caltech.edu/ Climate Modeling Alliance] as the sole implementation language for their next generation global climate model. This multi-million dollar project aims to build an earth-scale climate model providing insight into the effects and challenges of climate change.\"<ref name=\"Julia_Nvidia\"/>\n\n=== Sponsors ===\nJulia has received contributions from over 870 developers worldwide.<ref>{{Cite web|title=JuliaLang/julia: The Julia Language: A fresh approach to technical computing.|date=2019-01-26|url=https://github.com/JuliaLang/julia|publisher=The Julia Language|access-date=2019-01-26}}</ref> Dr. Jeremy Kepner at [[MIT Lincoln Laboratory]] was the founding sponsor of the Julia project in its early days. In addition, funds from the [[Gordon and Betty Moore Foundation]], the [[Alfred P. Sloan Foundation]], [[Intel]], and agencies such as [[National Science Foundation|NSF]], [[DARPA]], [[National Institutes of Health|NIH]], [[NASA]], and [[Federal Aviation Administration|FAA]] have been essential to the development of Julia.<ref>{{Cite web|url=https://julialang.org/research/|title=The Julia Language|website=julialang.org|access-date=2019-09-22}}</ref> [[Mozilla]], the maker of Firefox Web browser, with its research grants for H1 2019, sponsored \"a member of the official Julia team\" for the project \"Bringing Julia to the Browser\",<ref>{{Cite web|url=https://www.zdnet.com/article/mozilla-is-funding-a-way-to-support-julia-in-firefox/|title=Mozilla is funding a way to support Julia in Firefox|last=Cimpanu|first=Catalin|website=ZDNet|language=en|access-date=2019-09-22}}</ref> meaning to Firefox <!-- \"and the general browser environment--> and other web browsers.<ref>{{Cite web|url=https://alpha.iodide.io/notebooks/225/|title=Julia in Iodide|website=alpha.iodide.io|access-date=2019-09-22}}</ref><ref>{{Cite web|url=https://iodide-project.github.io/docs/language_plugins/|title=Language plugins - Iodide Documentation|website=iodide-project.github.io|access-date=2019-09-22}}</ref><ref>{{Cite web|url=https://mozilla-research.forms.fm/mozilla-research-grants-2019h1/forms/6510|title=Mozilla Research Grants 2019H1|website=Mozilla|language=en|quote=running language interpreters in WebAssembly. To further increase access to leading data science tools, we\u2019re looking for someone to port R or Julia to WebAssembly and to attempt to provide a level 3 language plugin for Iodide: automatic conversion of data basic types between R/Julia and Javascript, and the ability to share class instances between R/Julia and Javascript.|access-date=2019-09-22}}</ref><ref>{{Cite web|title=Literate scientific computing and communication for the web: iodide-project/iodide|date=2019-09-20|url=https://github.com/iodide-project/iodide|publisher=iodide|quote=We envision a future workflow that allows you to do your data munging in Python, fit a quick model in R or JAGS, solve some differential equations in Julia, and then display your results with a live interactive d3+JavaScript visualization&nbsp;... and all that within within a single, portable, sharable, and hackable file.|access-date=2019-09-22}}</ref>\n\n===Julia Computing===\nJulia Computing, Inc. was founded in 2015 by [[Viral B. Shah]], Deepak Vinchhi, [[Alan Edelman]], Jeff Bezanson, [[Stefan Karpinski]] and Keno Fischer.<ref>{{Cite web|url=https://juliacomputing.com/about-us|title=About Us \u2013 Julia Computing|website=juliacomputing.com|access-date=2017-09-12}}</ref>\n\nIn June 2017, Julia Computing raised $4.6M in seed funding from [[General Catalyst]] and [[Founder Collective]].<ref>https://juliacomputing.com/communication/2017/06/19/seed-funding.html</ref>\n\n==Language features==\nThough designed for numerical computing, Julia is a [[general-purpose programming language]].<ref>{{cite web\n  | title      = The Julia Language\n  | type       = official website\n  | url        = https://julialang.org/\n  | quote      = General Purpose [..] Julia lets you write UIs, statically compile your code, or even deploy it on a webserver.\n}}</ref>\nIt is also useful for low-level [[system programming|systems programming]],<ref name=\"LowLevelSystemsProgrammingInJulia\">{{cite web |url=http://juliacon.org/2018/talks_workshops/42/\n|archiveurl=https://web.archive.org/web/20181105083419/http://juliacon.org/2018/talks_workshops/42/\n|archivedate=5 November 2018\n|first=Todd |last=Green\n|title=Low-Level Systems Programming in High-Level Julia\n|date=10 August 2018\n|accessdate=5 November 2018\n}}</ref> as a [[specification language]],<ref name=\"spec\">{{cite web |url=http://juliacon.org/talks.html#friday\n|archiveurl=https://web.archive.org/web/20150701182804/http://juliacon.org/talks.html\n|archivedate=1 July 2015\n|first=Robert |last=Moss\n|title=Using Julia as a Specification Language for the Next-Generation Airborne Collision Avoidance System\n|quote=[[Airborne collision avoidance system]]\n|date=26 June 2015\n|accessdate=29 June 2015\n}}</ref> and for web programming at both server<ref>{{Cite web|url=https://medium.com/@richardanaya/how-to-create-a-multi-threaded-http-server-in-julia-ca12dca09c35|title=How to create a multi-threaded HTTP server in Julia|last=Anaya|first=Richard|date=2019-04-28|website=Medium|language=en|access-date=2019-07-25|quote=In summary, even though Julia lacks a multi-threaded server solution currently out of box, we can easily take advantage of its process distribution features and a highly popular load balancing tech to get full CPU utilization for HTTP handling.}}</ref><ref>{{Cite web|last=Anthoff|first=David|title=Node.js installation for julia|date=2019-06-01|url=https://github.com/davidanthoff/NodeJS.jl|access-date=2019-07-25}}</ref><!--<ref name=\"node-js\">{{cite web|url=https://node-julia.readme.io/|title=Getting Started with Node Julia \u00b7 Node Julia|date=|website=Node-julia.readme.io|accessdate=2017-05-31}}</ref> --> and client<ref name=\"JSExpr\"/><ref name=\"WebAssembly\"/> side.\n\nAccording to the official website, the main features of the language are:\n\n* [[Multiple dispatch]]: providing ability to define function behavior across many combinations of argument types\n* [[Dynamic type]] system: types for documentation, optimization, and dispatch\n* Good performance, approaching that of [[Type system|statically-typed]] languages like C\n* A built-in [[package manager]]\n* [[Lisp (programming language)|Lisp]]-like macros and other [[metaprogramming]] facilities\n* Call [[Python (programming language)|Python]] functions: use the PyCall package{{Efn|For calling the newer [[Python 3]] (the older default to call Python 2, is also still supported)<ref>{{cite web |url=https://github.com/JuliaPy/PyCall.jl |title=PyCall.jl |work=stevengj |publisher=github.com}}</ref><ref>{{cite newsgroup |url=https://groups.google.com/forum/#!topic/julia-users/lDM7-YXT2LU |title=Using PyCall in julia on Ubuntu with python3 |work=julia-users at Google Groups|quote=to import modules (e.g., python3-numpy)}}</ref> <!--([[PyPy]] and e.g. [[PHP]] was/is supported<ref name=\"Polyglot\">{{cite web|url=https://gitlab.com/wavexx/Polyglot.jl|title=wavexx / Polyglot.jl|website=GitLab|language=en|access-date=2019-07-25}}</ref> for Julia 0.5 (PyPy should work; supported by python-bond that Polyglot.jl is based on); [[Jython]] support is not confirmed, but since JavaCall.jl allows calling Java (and thus Scala) I assume also Jython.)--> and calling in the other direction, from Python to Julia, is also supported with ''pyjulia''.<ref>{{cite web |url=https://github.com/JuliaPy/pyjulia |title=python interface to julia}}</ref> \n<!--\nIt is not like Polyglot. jl does not support this for older Julia (and also interesting project to support other languages, e.g., PHP), but it has not been upgraded for Julia 1.0: Even calling [[recursive]]ly (back and forth) between these languages is possible, without (or with) using ''Polyglot.jl'',<ref name=\"Polyglot\"/> that supports additional languages to Python. \n-->\n\n}}\n* Call [[C (programming language)|C]] functions directly: no wrappers or special [[application programming interface|APIs]]\n* Powerful [[shell (computing)|shell]]-like abilities to manage other processes\n* Designed for [[Parallel computing|parallel]] and [[distributed computing]]\n* [[Coroutine|Coroutines]]: lightweight [[Green threads|''green'' threading]]\n* User-defined types are as fast and compact as built-ins\n* Automatic generation of efficient, specialized code for different argument types\n* Elegant and extensible conversions and promotions for numeric and other types\n* Efficient support for [[Unicode]], including but not limited to [[UTF-8]]\n<!-- |source=JuliaLang.org}} Only part missing it the MIT part, that is better explained elsewhere.-->\n\nMultiple dispatch (also termed [[multimethod]]s in Lisp) is a [[generalization]] of [[single dispatch]]&nbsp;\u2014 the [[Polymorphism (computer science)|polymorphic mechanism]] used in common [[object-oriented programming]] (OOP) languages&nbsp;\u2014 that uses [[Inheritance (object-oriented programming)|inheritance]]. In Julia, all concrete types are [[subtyping|subtypes]] of abstract types, directly or indirectly subtypes of the ''Any'' type, which is the top of the type hierarchy. Concrete types can not themselves be subtyped the way they can in other languages; composition is used instead (see also [[Inheritance (object-oriented programming)#Inheritance vs subtyping|inheritance vs subtyping]]).\n\nJulia draws significant inspiration from various dialects of Lisp<!-- Karpinski: \"In short, I would describe it as a Lisp with Matlab-like syntax\" https://www.reddit.com/r/programming/comments/pv3k9/why_we_created_julia_a_new_programming_language/ -->, including [[Scheme (programming language)|Scheme]] and [[Common Lisp]], and it shares many features with [[Dylan (programming language)|Dylan]], also a multiple-dispatch-oriented dynamic language (which features an [[ALGOL]]-like [[Free-form language|free-form]] [[Infix notation|infix]] syntax rather than a Lisp-like prefix syntax, while in Julia \"everything\"<ref name=\"Learn Julia in Y\">{{cite web|url=https://learnxinyminutes.com/docs/julia/ |title=Learn Julia in Y Minutes |website=Learnxinyminutes.com |date= |accessdate=2017-05-31}}</ref> is an [[Expression (computer science)|expression]]), and with [[Fortress (programming language)|Fortress]], another numerical programming language (which features multiple dispatch and a sophisticated parametric type system). While [[Common Lisp Object System]] (CLOS) adds multiple dispatch to Common Lisp, not all functions are generic functions.\n\nIn Julia, Dylan, and Fortress extensibility is the default, and the system's built-in functions are all generic and extensible. In Dylan, multiple dispatch is as fundamental as it is in Julia: all user-defined functions and even basic built-in operations like <code>+</code> are generic. Dylan's type system, however, does not fully support parametric types, which are more typical of the [[Generational list of programming languages#ML based|ML lineage of languages]]. By default, CLOS does not allow for dispatch on Common Lisp's parametric types; such extended dispatch semantics can only be added as an extension through the [[Common Lisp Object System#Metaobject Protocol|CLOS Metaobject Protocol]]. By convergent design, Fortress also features multiple dispatch on parametric types; unlike Julia, however, Fortress is statically rather than dynamically typed, with separate compiling and executing phases. The language features are summarized in the following table:\n\n{| class=\"wikitable\"\n|-\n! [[Programming language|Language]] !! [[Type system]] !! [[Generic function]]s !! [[Parametric polymorphism|Parametric types]]\n|-\n| Julia || Dynamic || Default || Yes\n|-\n| [[Common Lisp]] || Dynamic || Opt-in || Yes (but no dispatch)\n|-\n| [[Dylan (programming language)|Dylan]] || Dynamic || Default || Partial (no dispatch)\n|-\n| [[Fortress (programming language)|Fortress]] || Static || Default || Yes\n|}\n\nBy default, the Julia runtime must be pre-installed as user-provided source code is run. Alternatively, a standalone [[executable]] that needs no Julia source code can be built with ''ApplicationBuilder.jl''<ref>{{Cite web|last=Daly|first=Nathan|title=GitHub - NHDaly/ApplicationBuilder.jl: Compile, bundle, and release julia software.|date=2019-02-13|url=https://github.com/NHDaly/ApplicationBuilder.jl|access-date=2019-02-15}}</ref> and ''PackageCompiler.jl''.<ref>{{cite web|title=GitHub - JuliaLang/PackageCompiler.jl: Compile your Julia Package.|date=2019-02-14|url=https://github.com/JuliaLang/PackageCompiler.jl|publisher=The Julia Language|access-date=2019-02-15}}</ref><!--\n<ref>{{cite web |url=https://github.com/dhoegh/BuildExecutable.jl |title=Build a standalone executables from a Julia script}}</ref><ref>{{cite newsgroup|url=https://groups.google.com/forum/#!topic/julia-users/MtF4wHc77sw |title=.jl to .exe |website=Groups.google.com |date= |accessdate=2017-05-31}}</ref>  -->\n\nJulia's [[Macro (computer science)#Syntactic macros|syntactic macros]] (used for [[metaprogramming]]), like Lisp macros, are more powerful than [[Macro (computer science)#Text-substitution macros|text-substitution macros]] used in the [[preprocessor]] of some other languages such as C, because they work at the level of [[abstract syntax tree]]s (ASTs). Julia's macro system is [[hygienic macro|hygienic]], but also supports deliberate capture when desired (like for [[anaphoric macro]]s) using the <code>esc</code> construct.\n\n==Interaction==\nThe Julia official distribution includes a \"full-featured interactive command-line REPL\" ([[read\u2013eval\u2013print loop]]),<ref>{{Cite web|url=https://docs.julialang.org/en/v1/stdlib/REPL/|title=The Julia REPL \u00b7 The Julia Language|website=docs.julialang.org|access-date=2019-09-22}}</ref> with a searchable history, [[tab-completion]], many helpful keybindings, and dedicated help and [[shell (computing)|shell]] modes;<ref>{{Cite web|url=https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL|title=Introducing Julia/The REPL - Wikibooks, open books for an open world|website=en.wikibooks.org|quote=you can install the Julia package OhMyREPL.jl (https://github.com/KristofferC/OhMyREPL.jl) which lets you customize the REPL's appearance and behaviour|access-date=2019-09-22}}</ref> which can be used to experiment and test code quickly.<ref>{{Cite web|url=https://docs.julialang.org/en/v1/manual/getting-started/|title=Getting Started \u00b7 The Julia Language|website=docs.julialang.org|language=en|access-date=2018-08-15}}</ref> The following fragment represents a sample session example where strings are concatenated automatically by println:<ref>See also: https://docs.julialang.org/en/v1/manual/strings/ for string interpolation and the <code>string(greet, \", \", whom, \".\\n\")</code> example for preferred ways to concatenate strings. <!--While the <code>+</code> operator is not used for string concatenation, it could easily be defined to do so.--> Julia has the println and print functions, but also a @printf macro (i.e., not in function form) to eliminate run-time overhead of formatting (unlike the same function in C).</ref>\n\n<source lang=\"jlcon\">\njulia> p(x) = 2x^2 + 1; f(x, y) = 1 + 2p(x)y\njulia> println(\"Hello world!\", \" I'm on cloud \", f(0, 4), \" as Julia supports recognizable syntax!\")\nHello world! I'm on cloud 9 as Julia supports recognizable syntax!\n</source>\n\nThe REPL gives user access to the system shell and to help mode, by pressing <code>;</code> or <code>?</code> after the prompt (preceding each command), respectively. It also keeps the history of commands, including between sessions.<ref>{{cite web|title=Julia Documentation|url=https://docs.julialang.org|website=JuliaLang.org|accessdate=18 November 2014}}</ref> Code that can be tested inside the Julia's interactive section or saved into a file with a <code>.jl</code> extension and run from the command line by typing:<ref name=\"Learn Julia in Y\"/>\n\n<source lang=\"console\">\n $ julia <filename>\n</source>\n\nJulia is supported by [[Jupyter]], an online interactive \"notebooks\" environment.<ref>{{cite web |url=https://jupyter.org/ |title=Project Jupyter}}</ref>\n\n=== Use with other languages ===\nJulia is in practice [[interoperability|interoperable]] with many languages. Julia's <source lang=\"julia\" inline>ccall</source> keyword is used to call C-exported or Fortran shared library functions individually.\n\nJulia has support for [[Unicode 12.1]] (support for current Unicode 13.0 has been implemented<ref>{{Cite web|url=https://github.com/JuliaStrings/utf8proc/pull/179|title=Unicode 13 support by stevengj \u00b7 Pull Request #179 \u00b7 JuliaStrings/utf8proc|website=GitHub|language=en|access-date=2020-03-29}}</ref> for Julia 1.5), which added only one letter since Unicode 12.0,<ref>{{Cite web|url=https://github.com/JuliaLang/julia/pull/32002|title=support for Unicode 12.1.0 by stevengj \u00b7 Pull Request #32002 \u00b7 JuliaLang/julia|website=GitHub|language=en|access-date=2019-05-12}}</ref> with [[UTF-8]] used for strings (by default) and for Julia source code (only allowing legal UTF-8 in the latest version), meaning also allowing as an option common math symbols for many operators, such as \u2208 for the <code>in</code> operator.\n\nJulia has packages supporting markup languages such as [[HTML]] (and also for [[HTTP]]), [[XML]], [[JSON]] and [[BSON]], and for [[database]]s and Web use in general.\n\n== Usage ==\nLibraries such as [[Flux (machine-learning framework)|Flux]] and [[Knet (machine-learning framework)|Knet]] implement complete machine-learning frameworks written completely in Julia. [[Apache MXNet]] and [[TensorFlow]] are also available through wrapper libraries. [[Turing (probabilistic programming)|Turing]] and [[Gen (probabilistic programming)|Gen]] implement general-purpose [[probabilistic programming]] languages into Julia. [[Pharmacokinetics|Pharmacokinetic]] modeling and simulations are made available through the [[Pumas (pharmaceutical modeling)|Pumas]] suite.\n\n==Implementation==\nJulia's core is implemented in Julia and [[C (programming language)|C]]<!--C99, except for 0.4 needing C11 because of static asserts-->, together with [[C++]] for the [[LLVM]] dependency. The parsing and code-lowering are implemented in FemtoLisp, a [[Scheme (programming language)|Scheme]] dialect.<ref name=\"JeffBezanson 2019\">{{cite web | author=JeffBezanson | title=JeffBezanson/femtolisp | website=GitHub | date=June 6, 2019 | url=https://github.com/JeffBezanson/femtolisp | access-date=June 16, 2019}}</ref> The LLVM compiler infrastructure project is used as the [[Compiler#Back end|back end]] for generation of [[64-bit computing|64-bit]] or [[32-bit]] optimized [[machine code]] depending on the platform Julia runs on. With some exceptions (e.g., [[PCRE]]), the [[standard library]] is implemented in Julia. The most notable aspect of Julia's implementation is its speed, which is often within a factor of two relative to fully optimized C code (and thus often an order of magnitude faster than Python or [[R (programming language)|R]]).<ref name=\"Julia-TR\">{{cite web\n  | format       = PDF\n  | title        = Julia: A Fast Dynamic Language for Technical Computing\n  | url          = https://julialang.org/images/julia-dynamic-2012-tr.pdf\n  | year         = 2012\n  }}</ref><ref>{{cite web\n  | title        = How To Make Python Run As Fast As Julia\n  | url          = https://www.ibm.com/developerworks/community/blogs/jfp/entry/Python_Meets_Julia_Micro_Performance?lang=en\n  | year         = 2015\n  }}</ref><ref>{{cite web\n  | title        = Basic Comparison of Python, Julia, R, Matlab and IDL\n  | url          = https://modelingguru.nasa.gov/docs/DOC-2625\n  | year         = 2015\n  }}</ref> Development of Julia began in 2009 and an [[Open-source software|open-source]] version was publicized in February 2012.<ref name=\"announcement\">{{cite web\n  | title        = Why We Created Julia\n  | date         = February 2012\n  | website      = Julia website\n  | url          = https://julialang.org/blog/2012/02/why-we-created-julia\n  | accessdate   = 7 February 2013\n  }}</ref><ref>{{cite web\n  | last         = Gibbs\n  | first        = Mark\n  | title        = Pure and Julia are cool languages worth checking out\n  | url          = https://www.networkworld.com/columnists/2013/010913-gearhead.html\n  | type         = column\n  | work         = Network World\n  | date         = 9 January 2013\n  | accessdate   = 7 February 2013\n}}</ref>\n\n===Current and future platforms===\nWhile Julia uses JIT,<!-- Viral states \"Julia no longer uses the MCJIT in LLVM\" so this link is probably misleading:\n<ref>{{cite web |url=https://github.com/JuliaLang/julia/pull/5208\n|title=Support MCJIT\n|website=Github.com\n|accessdate=26 May 2015\n}}</ref> --> Julia generates native machine code directly, before a function is first run (not [[bytecode]]s that are run on a [[virtual machine]] (VM) or translated as the bytecode is running, as with, ''e.g.'', Java; the [[JVM]] or [[Dalvik (software)|Dalvik]] in Android).\n\nJulia has four support tiers,<ref>{{cite web|url=https://julialang.org/downloads/#support-tiers|title=Julia Downloads|website=julialang.org|access-date=2019-05-17}}</ref> and currently supports all [[x86-64]] processors, that are [[64-bit computing|64-bit]] (and is more [[program optimization|optimized]] for the latest generations) and all [[IA-32]] (\"x86\") processors except for decades old ones, i.e., in [[32-bit]] mode (\"i686\", excepting CPUs from the pre-[[Pentium 4]]-era); and supports more in lower tiers, e.g., ARM has tier 2 support: Julia \"fully supports ARMv8 (AArch64) processors, and supports ARMv7 and ARMv6 (AArch32) with some caveats.\"<ref>{{cite web|title=julia/arm.md|date=2019-11-29|url=https://github.com/JuliaLang/julia/blob/master/doc/build/arm.md|publisher=The Julia Language|quote=A list of [https://github.com/JuliaLang/julia/labels/arm known issues] for ARM is available.|access-date=2019-11-29}}</ref> [[CUDA]] (i.e. Nvidia GPUs; implementing [[Parallel Thread Execution|PTX]]) has tier 1 support, with the help of an [https://github.com/JuliaGPU/CUDAnative.jl external package]. There are also additionally packages supporting other accelerators, such as Google's [[tensor processing unit|TPU]]s,<ref>{{Citation|title=Julia on TPUs|date=2019-11-26|url=https://github.com/JuliaTPU/XLA.jl|publisher=JuliaTPU|access-date=2019-11-29}}</ref> and AMD's GPUs also have support with e.g. [[OpenCL]]. Julia's downloads page provides [[executable]]s (and source) for all the officially supported platforms.\n\nOn some platforms, Julia may need to be compiled from [[source code]] (e.g., the original [[Raspberry Pi]]), with specific build options. Julia has been \"successfully built\" <!--on the following ARMv8 devices:\n\n* [https://www.nvidia.com/object/embedded-systems-dev-kits-modules.html nVidia Jetson TX1 & TX2];\n* [https://www.apm.com/products/data-center/x-gene-family/x-gene/ X-Gene 1];\n* [https://softiron.com/products/overdrive-3000/ Overdrive 3000];\n* [https://www.cavium.com/ThunderX_ARM_Processors.html Cavium ThunderX]-->\non several ARM platforms, up to, e.g., \"ARMv8 Data Center & Cloud Processors\", such as [https://www.cavium.com/ThunderX_ARM_Processors.html Cavium ThunderX] (first ARM with 48 cores). PowerPC (64-bit) has tier 3 support, meaning it \"may or may not build\".\n<!--\n Support for ARM, [[AArch64]], and [[Power Architecture|POWER8]] (little-endian) has been added recently as of 0.5.1 is available too.<ref>{{cite web|author= |url=https://github.com/JuliaLang/julia/blob/v0.5.2/README.md |title=julia/README.md at v0.5.2 \u00b7 JuliaLang/julia \u00b7 GitHub |website=Github.com |date=2017-05-03 |accessdate=2017-05-31}}</ref>\n\nand in 0.5.x:\n\n\"work in progress\" text dropped with (not yet backported (possibly the text, only docs left behind?) to 0.6.x): https://github.com/JuliaLang/julia/commit/dcffef03594779402bb5c2666fbcf24b4438adba#diff-8b8b297c5626992d7377a6bbb3aadceb\n\n\"only supports ARMv7\" text dropped on master (may apply on older, meaning possibly only for ARMv6?:\n\n\"[[Nightly build]]s are available for ARMv7-A. [..] Note that OpenBLAS only supports ARMv7. For older ARM variants, using the reference BLAS may be the simplest thing to do. [..] Note: These [Raspberry Pi] chips use ARMv6, which is not well supported at the moment. However it is possible to get a working Julia build. [e.g., supported] [[Tegra#Tegra P1|nVidia Jetson TX2]] [with] CUDA functionality\"<ref>{{cite web|author=JuliaLang |url=https://github.com/JuliaLang/julia/blob/v0.6.2/README.arm.md |title=julia/README.arm.md at v0.5.2 \u00b7 JuliaLang/julia \u00b7 GitHub |publisher=Github.com |date= |accessdate=2017-05-31}}</ref>\n\nThe [[Raspberry Pi]] support also includes limited support for [[Raspberry Pi]] 1 (since it has [[ARMv6]]),<ref>{{cite web |url=https://github.com/JuliaLang/julia/issues/10488\n|title=Cross-compiling for ARMv6\n|quote=I believe #10917 should fix this. The CPU used there <code>arm1176jzf-s</code>. Please reopen if it does not.\n|accessdate=16 May 2015}}\n</ref><ref>\n{{cite web |url=https://github.com/JuliaLang/julia/issues/10235\n|title=ARM build failing during bootstrap on Raspberry Pi 2\n|quote=I can confirm (FINALLY) that it works on the Raspberry Pi 2 [..] I guess we can announce alpha support for arm in 0.4 as well. |accessdate=16 May 2015}}</ref>\n\n-->\nJulia is now supported in [[Raspbian]]<ref>{{cite web |url=https://julialang.org/blog/2017/05/raspberry-pi-julia |title=Julia available in Raspbian on the Raspberry Pi |quote=Julia works on all the Pi variants, we recommend using the Pi 3.}}</ref> while support is better for newer Pis, e.g., those with ARMv7 or newer; the Julia support is promoted by the [[Raspberry Pi Foundation]].<ref>{{cite web |url=https://www.raspberrypi.org/blog/julia-language-raspberry-pi/ |title=Julia language for Raspberry Pi |work=[[Raspberry Pi Foundation]]}}</ref> There's also support for Web browsers/[[JavaScript]] through JSExpr.jl;<ref name=\"JSExpr\">{{Cite web|title=Translate Julia to JavaScript |date=2019-07-07|url=https://github.com/JuliaGizmos/JSExpr.jl|publisher=JuliaGizmos|access-date=2019-07-25}}</ref> and the alternative language of Web browsers, [[WebAssembly]], has support<ref name=\"WebAssembly\">{{Cite web|last=Fischer|first=Keno|title=Running julia on wasm|date=2019-07-22|url=https://github.com/Keno/julia-wasm|access-date=2019-07-25}}</ref> through minimal support in Julia, that supports several upcoming external Julia projects.\n<!--\nJulia supports [[64-bit computing|64-bit]] [[ARM architecture|ARM]] and [[PowerPC]] and \"fully supports [[ARMv8]] ([[AArch64]]) processors, and supports ARMv7 and ARMv6 (AArch32) with some caveats\"<ref>https://github.com/JuliaLang/julia/blob/master/README.arm.md</ref><ref>https://github.com/JuliaLang/julia/issues/10791#issuecomment-91735439</ref> and [[PowerPC]] being worked on, with almost no open specific issues,<ref>https://github.com/JuliaLang/julia/labels/Power</ref><ref>{{cite web |url=https://groups.google.com/forum/#!topic/julia-dev/BYVCyUlNR8c |title=Porting Julia to PowerPC |quote=Wow, the latest git allows me to build to completion. |accessdate=9 May 2015}}</ref> with [[Executable|binaries]] available for [[POWER7]] (\"due to some small support from [[IBM]]\") and [[POWER8]], that are expected to have official beta support as of 0.5 (at least for non-parallel support).<ref>{{cite web |url=https://groups.google.com/forum/#!topic/julia-users/xB0k7XMBNqM |title=IBM Power port |quote=I am hoping we can have beta support from the 0.5 release onwards for sequential julia. We were able to do this work due to some small support from IBM.}}</ref>\n-->\n<!--\nSupport for [[GNU/kFreeBSD]] and [[GNU Hurd]] is being worked on (in JuliaLang's [[C mathematical functions#libm|openlibm]] dependency project).<ref>{{cite web|url=https://github.com/JuliaLang/openlibm/pull/129 |title=Fix building tests on GNU/kFreeBSD and GNU/Hurd by ginggs \u00b7 Pull Request #129 \u00b7 JuliaLang/openlibm |website=Github.com |date= |accessdate=2017-05-31}}</ref>\nYes, openlibm, is not Julia, but is a dependency of it-->\n<!--\nAn unofficial Julia-lite,<ref>https://github.com/ScottPJones/julia/tree/spj/lite</ref>a trimmed down fork (by now outdated) is a available. Officially Julia has been dropping dependencies and features from the standard library, to make GPL-free (one left), so it's also the official plan.\n-->\nJulia can compile to ARM; thus, in theory, [[Android app]]s can be made, but for now only Julia (and most packages) has been made to run under [[Android (operating system)|Android]] indirectly, ''i.e.'', in Ubuntu on Android.<ref>{{Cite web|url=https://discourse.julialang.org/t/using-julia-on-android/8086/7|title=Using Julia on Android?|date=2019-09-27|website=JuliaLang|language=en-US|access-date=2019-10-02}}</ref>\n\n==See also==\n* [[Comparison of numerical analysis software]]\n* [[Comparison of statistical packages]]\n\n==Notes==\n{{Notelist|80em}}\n\n==References==\n{{Reflist|30em}}\n\n==Further reading==\n* {{cite book|last=Nagar|first=Sandeep|year=2017|title=Beginning Julia Programming-For Engineers and Scientists|publisher=Springer}}\n* {{cite journal|author1=Bezanson, J|author2=Edelman, A|author3=Karpinski, S|author4=Shah, V. B|year=2017|title=Julia: A fresh approach to numerical computing|publisher=SIAM Review |volume=59 |issue=1 |pages=65\u201398}}\n* {{cite book|last=Joshi|first=Anshul|year=2016|title=Julia for Data Science \uff0d Explore the world of data science from scratch with Julia by your side|publisher=Packt Publishing}}\n\n==External links==\n{{Wikibooks|Introducing Julia}}\n* {{Official website|https://julialang.org}}\n* [https://github.com/JuliaLang/julia Source code]\n\n{{Programming languages}}\n{{FOSS}}\n{{Numerical analysis software}}\n{{Mathematical optimization software}}\n{{Statistical software}}\n\n[[Category:2012 software]]\n[[Category:Array programming languages]]\n[[Category:Computational notebook]]\n[[Category:Cross-platform software]]\n[[Category:Data mining and machine learning software]]\n[[Category:Data-centric programming languages]]\n[[Category:Dynamically typed programming languages]]\n[[Category:Free compilers and interpreters]]<!-- note there's also a Julia interpreter (not on by default); beside FemptoLisp-->\n[[Category:Free computer libraries]]\n[[Category:Free data analysis software]]\n[[Category:Free data visualization software]]\n[[Category:Free software projects]]\n[[Category:Free software programmed in C]]\n[[Category:Free statistical software]]\n[[Category:Functional languages]]\n[[Category:High-level programming languages]]\n[[Category:Lisp programming language_family]]\n[[Category:Multi-paradigm programming languages]]<!-- ok? Mostly only using the main paradigm multiple-dispatch, but Julia enables using more, e.g. implementing class-based OO-->\n[[Category:Numerical analysis software for Linux]]\n[[Category:Numerical analysis software for MacOS]]\n[[Category:Numerical analysis software for Windows]]\n[[Category:Numerical libraries]] <!--for Julia's standard library: seems ok, as e.g. part of (and all planned) C's libm has been rewritten in Julia-->\n[[Category:Numerical linear algebra]]\n[[Category:Numerical programming languages]]\n[[Category:Object-oriented programming languages]]\n[[Category:Parallel computing]]\n[[Category:Procedural programming languages]]\n[[Category:Programming languages]]\n[[Category:Programming languages created in 2012]]\n[[Category:Software using the MIT license]]\n<!-- [[Category:Scripting languages]] ? -->\n[[Category:Statistical programming languages]]\n[[Category:Text-oriented programming languages]]\n[[Category:Homoiconic programming languages]]\n[[Category:Articles with example Julia code]]\n[[Category:Free software programmed in Julia]] <!-- Julia is written, mostly, in Julia -->\n", "text_old": "{{Use dmy dates|date=October 2015}}\n{{Infobox programming language\n| name = Julia\n| logo = Julia Programming Language Logo.svg\n| logo caption = \n| screenshot = <!-- filename is enough -->\n| screenshot caption = \n| paradigm = [[multi-paradigm programming language|Multi-paradigm]]: [[multiple dispatch]] (core), [[procedural programming|procedural]], [[functional programming|functional]], [[metaprogramming|meta]], [[multistaged programming|multistaged]]<ref>{{cite web |url=https://medium.com/@acidflask/smoothing-data-with-julia-s-generated-functions-c80e240e05f3#.615wk3dle |title=Smoothing data with Julia's @generated functions |quote=Julia's generated functions are closely related to the multistaged programming (MSP) paradigm popularized by Taha and Sheard, which generalizes the compile time/run time stages of program execution by allowing for multiple stages of delayed code execution. |date=5 November 2015 |accessdate=9 December 2015}}</ref>\n| released = {{Start date and age|2012}}<ref name=\"announcement\"/>\n| designer = Jeff Bezanson, [[Alan Edelman]], [[Stefan Karpinski]], [[Viral B. Shah]]\n| developer = Jeff Bezanson, [[Stefan Karpinski]], [[Viral B. Shah]], and other contributors<ref name=\"license\">{{cite web\n  | url = https://github.com/JuliaLang/julia/blob/master/LICENSE.md\n  | title = LICENSE.md\n  | publisher = [[GitHub]]\n  }}</ref><ref>{{cite web\n  | url = https://github.com/JuliaLang/julia/graphs/contributors\n  | title = Contributors to JuliaLang/julia\n  | publisher = [[GitHub]]\n  }}</ref>\n| latest release version = 1.4.0<ref>{{cite web|author= |url=https://github.com/JuliaLang/julia/releases/tag/v1.4.0 |title=v1.4.0 |website=Github.com |date=2020-03-21 |accessdate=2020-03-21}}</ref>\n| latest release date = {{Start date and age|2020|03|21|df=yes}}\n| latest preview version = <!--1.4.0-rc2<ref>{{cite web|author= |url=https://github.com/JuliaLang/julia/releases/tag/v1.4.0-rc2 |title=v1.4.0-rc2 |website=Github.com |date=2020-02-24 |accessdate=2020-02-24}}</ref>\n| latest preview date = {{Start date and age|2020|02|24|df=yes}} / --> 1.5.0-DEV with daily updates (and 1.4.1 worked on<ref>https://github.com/JuliaLang/julia/pull/35229</ref>)\n| typing = [[dynamic programming language|Dynamic]], [[nominal type system|nominative]], [[parametric polymorphism|parametric]], [[optional typing|optional]]\n| implementations = \n| dialects = \n| influenced by = {{Flatlist}}\n* [[C (programming language)|C]]<ref name=\"announcement\"/>\n* [[Lisp (programming language)|Lisp]]<ref name=\"announcement\"/><!--only the parser implemented by femtolisp, a [[Scheme (programming language)|Scheme]]-like implementation (see: \"unsupported\" \"julia --lisp\" that invokes it, but its only influence on the language/syntax \u2013 Lisp-like macros? Maybe not even Lisp's CLOS \"multimethods\"? as Dylan with \"multiple dispatch\" was cut from the list-->\n* [[Lua (programming language)|Lua]]<ref name=\"Introduction\">{{Cite web|url=https://docs.julialang.org/en/v1/|title=<!--Chapter: Introduction under --> Home \u00b7 The Julia Language|website=docs.julialang.org|language=en|access-date=2018-08-15}}</ref>\n* [[Mathematica]]<ref name=\"announcement\"/> (strictly its [[Wolfram Language]]<ref name=\"announcement\"/><ref>{{cite web |url=https://fatiherikli.github.io/programming-language-network/ |title=Programming Language Network |publisher=GitHub |accessdate=6 December 2016}}</ref>)\n* [[MATLAB]]<ref name=\"announcement\"/>\n* [[Perl]]<ref name=\"Introduction\"/>\n* [[Python (programming language)|Python]]<ref name=\"Introduction\"/>\n* [[R (programming language)|R]]<ref name=\"announcement\"/>\n* [[Ruby (programming language)|Ruby]]<ref name=\"Introduction\"/>\n* [[Scheme (programming language)|Scheme]]<ref name=\"JuliaCon2016\">{{cite web |url=http://www.juliacon.org |title=JuliaCon 2016 |publisher=JuliaCon |quote=\"He has co-designed the programming language Scheme, which has greatly influenced the design of Julia\"|accessdate=6 December 2016}}</ref>\n{{endflatlist}}\n| influenced = \n| programming language = Julia, [[C (programming language)|C]],<!--\"Remove when C11 is required for C code\" https://github.com/JuliaLang/julia/search?utf8=%E2%9C%93&q=C11&type=\n\n\"These roughly follows the c11/c++11 memory model [..] The only exception is the GC safepoint and GC state transitions [..] We use the compiler intrinsics to implement a similar API to the c11/c++11\" https://github.com/JuliaLang/julia/blob/44f3d7c921cbe50105a54258db2febb65a4b9d44/src/julia_threads.h\n--> [[C++]], [[Scheme (programming language)|Scheme]], [[LLVM]]<ref name=\"JuliaHome\">{{cite web |url=https://julialang.org/ |title=Julia |author=<!--Staff writer(s); no by-line.--> |date=<!--None listed.--> |website=Julia |publisher=[[NumFocus]] project |access-date=9 December 2016 |quote=Julia's Base library, largely written in Julia itself, also integrates mature, best-of-breed open source C and Fortran libraries for ...}}</ref>\n| platform = Tier&nbsp;1: [[x86-64]], [[IA-32]], [[CUDA]]<br />Tier&nbsp;2: [[ARM architecture|ARM]] (both 32- and 64-bit)<br /> Tier&nbsp;3: [[PowerPC]]<br />Also has web browser support (for [[JavaScript]] and [[WebAssembly]])<ref name=\"WebAssembly\"/> and works in [[Android (operating system)|Android]].\n| operating system = [[Linux]], [[macOS]], [[Microsoft Windows|Windows]] and <!-- no longer just community support for --> [[FreeBSD]]\n| license = [[MIT License|MIT]] (core),<ref name=\"license\"/><!--for core language while, by default, \"the environment, which consists of the language, user interfaces, and libraries, is under the GPL\"--> [[General Public Licence|GPL v2]];<ref name=\"JuliaHome\" /><ref>{{cite newsgroup|url=https://groups.google.com/forum/#!topic/julia-users/v4OjEK7azBs |title=Non-GPL Julia? |website=Groups.google.com |date= |accessdate=2017-05-31}}</ref><!--as some few libraries used by the standard library (that can be excluded) are [[copyleft]]--> a [[makefile]] option omits GPL libraries<ref>{{cite web |url=https://github.com/JuliaLang/julia/pull/10870 |title=Introduce USE_GPL_LIBS Makefile flag to build Julia without GPL libraries |quote=Note that this commit does not remove GPL utilities such as git and busybox that are included in the Julia binary installers on Mac and Windows.<!--dropped as of 0.5 then only libgit2--> It allows building from source with no GPL library dependencies.}}</ref>\n| file ext = .jl\n| website = {{Official website|https://JuliaLang.org|name=JuliaLang.org}}\n}}\n\n'''Julia''' is a [[high-level programming language|high-level]], high-performance, dynamic [[programming language]]. While it is a general purpose language and can be used to write any application, many of its features are well-suited for high-performance [[numerical analysis]] and [[computational science]].<ref>{{cite web\n  | date       = 15 October 2012\n  | last       = Bryant\n  | first      = Avi\n  | title      = Matlab, R, and Julia: Languages for data analysis\n  | url        = https://strata.oreilly.com/2012/10/matlab-r-julia-languages-for-data-analysis.html\n  | archiveurl = https://web.archive.org/web/20140426110631/https://strata.oreilly.com/2012/10/matlab-r-julia-languages-for-data-analysis.html\n  | archivedate= 2014-04-26\n  | publisher  = O'Reilly Strata\n  }}</ref><ref>{{cite web\n  | date       = 23 August 2015\n  | last       = Singh\n  | first      = Vicky\n  | title      = Julia Programming Language \u2013 A True Python Alternative\n  | url        = https://www.technotification.com/2018/08/julia-programming-language.html\n  | publisher  = Technotification\n  }}</ref><ref>{{cite magazine\n  | last       = Krill\n  | first      = Paul\n  | title      = New Julia language seeks to be the C for scientists\n  | url        = https://www.infoworld.com/d/application-development/new-julia-language-seeks-be-the-c-scientists-190818\n  | magazine   = InfoWorld\n  | date       = 18 April 2012\n  }}</ref><ref>{{cite magazine\n  | last       = Finley\n  | first      = Klint\n  | title      = Out in the Open: Man Creates One Programming Language to Rule Them All\n  | url        = https://www.wired.com/2014/02/julia/\n  | magazine   = Wired\n  | date       = 3 February 2014\n  }}</ref>\n\nDistinctive aspects of Julia's design include a type system with [[parametric polymorphism]] in a [[dynamic programming language]]; with [[multiple dispatch]] as its core [[programming paradigm]]. Julia supports [[Concurrent computing|concurrent]], (composable) [[parallel computing|parallel]] and [[distributed computing]] (with or without using [[Message Passing Interface|MPI]]<ref>{{cite web|title=GitHub - JuliaParallel/MPI.jl: MPI wrappers for Julia.|url=https://github.com/JuliaParallel/MPI.jl|publisher=Parallel Julia|access-date=2019-09-22}}</ref> and/or the built-in corresponding<ref>{{Cite web|url=https://discourse.julialang.org/t/questions-about-getting-started-with-parallel-computing/25341/3?u=palli|title=Questions about getting started with parallel computing|date=2019-06-16|website=JuliaLang|language=en-US|access-date=2019-10-08}}</ref> to \"[[OpenMP]]-style\" threads<ref>{{Cite web|url=https://discourse.julialang.org/t/julia-and-concurrency/25556/2|title=Julia and Concurrency|date=2019-06-24|website=JuliaLang|language=en-US|access-date=2019-09-22}}</ref>), and [[foreign function interface|direct calling]] of [[C (programming language)|C]] and [[Fortran]] libraries without [[adapter pattern#gluecode|glue code]]. A [[Just-in-time compilation|just-in-time]] compiler that is referred to as \"just-[[Ahead-of-time compilation|ahead-of-time]]\"<ref>{{cite web |last1=Fischer |first1=Keno |last2=Nash |first2=Jameson |title=Growing a Compiler - Getting to Machine Learning from a General Purpose Compiler |url=https://juliacomputing.com/blog/2019/02/19/growing-a-compiler.html |website=Julia Computing Blog |accessdate=11 April 2019}}</ref> in the Julia community is used.\n\nJulia is [[garbage collection (computer science)|garbage-collected]],<ref>{{cite newsgroup|url=https://groups.google.com/forum/#!topic/julia-users/6_XvoLBzN60 |title=Suspending Garbage Collection for Performance...good idea or bad idea? |website=Groups.google.com |date= |accessdate=2017-05-31}}</ref> uses [[eager evaluation]], and includes efficient libraries for [[floating-point]] calculations, [[linear algebra]], [[random number generation]], and [[regular expression]] matching. Many libraries are available, including some (e.g., for [[fast Fourier transform]]s) that were previously bundled with Julia and are now separate.<ref>now available with <code>using [[FFTW]]</code> in current versions (That dependency, is one of many which, was moved out of the standard library to a package because it is GPL licensed, and thus is not included in Julia 1.0 by default.) {{Cite web|url=https://github.com/JuliaLang/julia/pull/21956|title=Remove the FFTW bindings from Base by ararslan \u00b7 Pull Request #21956 \u00b7 JuliaLang/julia|website=GitHub|language=en|access-date=2018-03-01}}</ref>\n\nTools available for Julia include, not just many widely used editors, such as [[Vim (text editor)|Vim]] and [[Emacs]], but also [[integrated development environment|IDEs]] (e.g. Juno, and Microsoft's [[Visual Studio Code]], with [[Plug-in (computing)|extensions]] adding Julia support, both providing debugging support); with integrated tools, e.g. a [[lint (software)|linter]],<ref>{{Cite web|url=https://discourse.julialang.org/t/ann-linter-julia-plugin-for-atom-juno/2118|title=ANN: linter-julia plugin for Atom / Juno|date=2017-02-15|website=JuliaLang|language=en|access-date=2019-04-10}}</ref> [[profiling (computer programming)|profiler]] (and flame graph support available<ref>{{Citation|last=Holy|first=Tim|title=GitHub - timholy/ProfileView.jl: Visualization of Julia profiling data.|date=2019-09-13|url=https://github.com/timholy/ProfileView.jl|access-date=2019-09-22}}</ref><ref>{{Citation|last=Gregg|first=Brendan|title=GitHub - brendangregg/FlameGraph: Stack trace visualizer.|date=2019-09-20|url=https://github.com/brendangregg/FlameGraph|access-date=2019-09-22}}</ref> for the built-in one), debugger,<ref>{{Cite web|url=https://julialang.org/blog/2019/03/debuggers|title=A Julia interpreter and debugger|website=julialang.org|access-date=2019-04-10}}</ref> and the Rebugger.jl package \"supports [[interactive programming|repeated-execution debugging]]\"{{Efn|<!--quote= --> [With Rebugger.jl] you can:\n* test different modifications to the code or arguments as many times as you want; you are never forced to exit \u201cdebug mode\u201d and save your file\n* run the same chosen block of code repeatedly (perhaps trying out different ways of fixing a bug) without needing to repeat any of the \u201csetup\u201d work that might have been necessary to get to some deeply nested method in the original call stack.<ref name=\"Rebugger\">{{Cite web|url=https://discourse.julialang.org/t/ann-rebugger-interactive-debugging-for-julia-0-7-1-0/13843|title=[ANN] Rebugger: interactive debugging for Julia 0.7/1.0|quote=<!--Better in the \"Efn\" footnote above?-->\n|date=2018-08-21|website=JuliaLang|language=en|access-date=2019-04-10}}</ref>}} and more.<ref>{{Cite web|url=https://timholy.github.io/Rebugger.jl/dev/|title=Home \u00b7 Rebugger.jl|website=timholy.github.io|access-date=2019-04-10}}</ref>\n\n==History==\nWork on Julia was started in 2009, by Jeff Bezanson, [[Stefan Karpinski]], [[Viral B. Shah]], and [[Alan Edelman]], who set out to create a free language that was both high-level and fast. On 14 February 2012, the team launched a website with a blog post explaining the language's mission.<ref>{{cite web|last1=Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman|title=Why We Created Julia|url=https://julialang.org/blog/2012/02/why-we-created-julia|website=JuliaLang.org|accessdate=5 June 2017}}</ref>  In an interview with InfoWorld in April 2012, Karpinski said of the name \"Julia\": \"There's no good reason, really. It just seemed like a pretty name.\"<ref>[[Stefan Karpinski]], [https://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html New Julia language seeks to be the C for scientists], [[InfoWorld]], 18 April 2012</ref> Bezanson said he chose the name on the recommendation of a friend.<ref>{{cite web |last1=Torre |first1=Charles |title=Stefan Karpinski and Jeff Bezanson on Julia |url=https://channel9.msdn.com/Blogs/Charles/Stefan-Karpinski-and-Jeff-Bezanson-Julia-Programming-Language |website=Channel 9 |publisher=MSDN |accessdate=4 December 2018}}</ref>\n\nSince the 2012 launch, the Julia community has grown, with over 13,000,000 downloads {{as of|2020|03|lc=y}} (and is used at more than 1,500 universities),<ref>{{Cite web|url=https://juliacomputing.com/|title=Julia Computing|website=juliacomputing.com||access-date=2020-04-05}}</ref><ref>{{Cite web|url=https://juliacomputing.com/blog/2019/11/07/november-newsletter.html|title=Newsletter November 2019|date=2019-11-07|website=juliacomputing.com|access-date=2019-11-29}}</ref><ref>{{Cite web|url=https://juliacomputing.com/blog/2019/01/04/january-newsletter.html |title=Julia Computing Newsletter, Growth Metrics|website=juliacomputing.com|access-date=2019-02-11}}</ref> The Official Julia Docker images, at [[Docker, Inc.|Docker Hub]], have seen over 4,000,000 downloads as of January 2019.<ref>{{Cite web|url=https://juliacomputing.com/blog/2019/01/04/january-newsletter.html|title=Newsletter January 2019|website=juliacomputing.com|date=4 January 2019|access-date=2019-08-20}}</ref><ref>https://hub.docker.com/_/julia</ref> The JuliaCon<ref>{{cite web|url=http://juliacon.org/ |title=JuliaCon website |website=juliacon.org |accessdate=2018-05-10}}</ref> [[academic conference]] for Julia users and developers has been held annually since 2014.\n\nVersion 0.3 was released in August 2014, version 0.4 in October 2015, version 0.5 in October 2016,<ref>[https://julialang.org/blog/ The Julia Blog]</ref> and version 0.6 in June 2017.<ref>https://julialang.org/blog/2017/06/julia-0.6-release</ref>  Both Julia 0.7 (a useful release for testing packages, and for knowing how to upgrade them for 1.0<ref>{{Cite web|url=https://discourse.julialang.org/t/what-is-julia-0-7-how-does-it-relate-to-1-0/9994|title=What is Julia 0.7? How does it relate to 1.0?|website=JuliaLang|language=en|access-date=2018-10-17}}</ref>) and version 1.0 were released on 8 August 2018. Work on Julia 0.7 was a \"huge undertaking\" (e.g., because of \"entirely new optimizer\"), and some changes were made to semantics, e.g. the [[iteration]] interface was simplified;<ref>{{Cite web|url=https://julialang.org/blog/2018/07/iterators-in-julia-0.7 |title=Writing Iterators in Julia 0.7 |authors=Eric Davies |website=julialang.org |access-date=2018-08-05}}</ref> and the syntax changed a little (with the syntax now stable, and same for 1.x and 0.7).\n\nThe release candidate for Julia 1.0 (Julia 1.0.0-rc1) was released on 7 August 2018, and the final version a day later (and by now, Julia 1.0.x are the oldest versions still supported, having [[long-term support]]; for at least a year). Julia 1.1 was released in January 2019 with, e.g., a new \"exception stack\" language feature. Bugfix releases are expected roughly monthly, for 1.4.x and 1.0.x and Julia 1.0.1 up to 1.0.5 have followed that schedule. Julia 1.2 was released in August 2019, and it has e.g. some built-in support for web browsers (for testing if running in [[JavaScript]] VM),<ref>{{Cite web|title=Sys.isjsvm([os])|date=2019-08-20|url=https://github.com/JuliaLang/julia/blob/75c10e435b2b9c947422ad38fa0b020595d3f747/base/sysinfo.jl#L401|quote=Predicate for testing if Julia is running in a JavaScript VM (JSVM), including e.g. a WebAssembly JavaScript embedding in a web browser.|publisher=The Julia Language|access-date=2019-08-20}}</ref> and Julia 1.4 in March 2020 (and with it Julia 1.3.x, 1.2.x and Julia 1.1.x releases are no longer maintained). Julia 1.3 added e.g. composable multi-threaded parallelism and a binary artifacts system for Julia packages.<ref>{{Cite web|url=https://julialang.org/blog/2019/11/artifacts|title=The Julia Language|others=Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al <!--|others=et al |authors5=et al-->|website=julialang.org|access-date=2019-12-13}}</ref> \n\nJulia 1.4 allowed better syntax for array indexing to handle e.g. [[zero-based_numbering#Usage_in_programming_languages|0-based]] arrays, with {{code|A[begin+1]}} for '''second''' element of array A.<ref>{{Cite web|url=https://github.com/JuliaLang/julia/pull/33946|title=support a[begin] for a[firstindex(a)] by stevengj \u00b7 Pull Request #33946 \u00b7 JuliaLang/julia|website=GitHub|language=en|access-date=2020-04-07}}</ref> It also changed the memory model.<ref>{{Cite web|url=https://github.com/JuliaLang/julia/pull/32448|title=For structs with all isbits or isbitsunion fields, allow them to be s<!--\u2026-->tored inline in arrays <!--by quinnj--> \u00b7 Pull Request #32448 \u00b7 JuliaLang/julia|author=quinnj|quote=I still keep running into problems that this causes internally because it was a breaking change that changes assumptions made by some users and inference/codegen.|website=GitHub|language=en|access-date=2020-04-07}}</ref>\n\nMost packages that work in Julia 1.0.x also work in 1.1.x or newer, enabled by the [[forward compatibility|forward compatible]] syntax guarantee. A major exception was, for interacting with non-Julia code, the JavaCall.jl package (however calling other languages, e.g. [[R (programming language)|R language]] works, with the package for R fixed<ref>{{Cite web|url=https://github.com/JuliaInterop/RCall.jl/pull/293|title=Fix for C stack checking issues on 1.1 by simonbyrne \u00b7 Pull Request #293 \u00b7 JuliaInterop/RCall.jl|website=GitHub|language=en|access-date=2019-08-10}}</ref>) to call Java, Scala etc. This was fixed by Java 11,<ref>{{Cite web|url=https://github.com/JuliaInterop/JavaCall.jl/issues/96#issuecomment-534178269|title=StackOverflowError in `JavaCall.init` for Julia 1.1.0 \u00b7 Issue #96 \u00b7 JuliaInterop/JavaCall.jl|website=GitHub|language=en|access-date=2019-10-21}}</ref> or alternatively to use those languages with Julia (on older JVM), for e.g. [[Java Database Connectivity|JDBC]].jl or [[Apache Spark]] (through Spark.jl), users could choose to stay with the LTS version of Julia.<ref>{{Cite web|url=https://github.com/JuliaLang/julia/issues/31104|title=JVM fails to load in 1.1 (JavaCall.jl) \u00b7 Issue #31104 \u00b7 JuliaLang/julia|quote=JeffBezanson modified the milestones: 1.3, 1.4|website=GitHub|language=en|access-date=2019-08-18}}</ref> <!--A milestone was set for a fix in Julia 1.4 (while there's already a workaround in Julia 1.3.0<ref>{{Cite web|url=https://github.com/JuliaLang/julia/commit/ae4e08c5581a077ea269a9bd5a351082104f6daf|title=add environment variable `JULIA_ALWAYS_COPY_STACKS` (#32885) \u00b7 JuliaLang/julia@ae4e08c|website=GitHub|language=en|access-date=2019-08-18}}</ref>), to support older Java, which has-->  Julia 1.4 had a milestone set for 15 December 2019 and for Julia 1.5 the due date is 15 April 2020. Milestones for Julia 2.0 (and later, e.g. 3.0) currently have no set due dates.<ref>{{Cite web|title=Milestones - JuliaLang/julia|url=https://github.com/JuliaLang/julia/milestones|publisher=The Julia Language|access-date=2019-12-13}}</ref>\n\n===Notable uses===\nJulia has attracted some high-profile users, from investment manager [[BlackRock]], which uses it for [[time-series analytics]], to the British insurer [[Aviva]], which uses it for [[risk calculations]]. In 2015, the [[Federal Reserve Bank of New York]] used Julia to make models of the United States economy, noting that the language made model estimation \"about 10 times faster\" than its previous [[MATLAB]] implementation. Julia's co-founders established Julia Computing in 2015 to provide paid support, training, and consulting services to clients, though Julia remains free to use. At the 2017 JuliaCon<ref>{{cite web|url=http://juliacon.org/2017/ |title=JuliaCon 2017 |website=juliacon.org |accessdate=2017-06-04}}</ref> conference, Jeffrey Regier, [[Keno Fischer]] and others announced<ref>{{cite web|last1=Fisher|first1=Keno|title=The Celeste Project|url=https://juliacon2017.sched.com/speaker/thecelesteproject|website=juliacon.org|accessdate=24 June 2017}}</ref> that the Celeste project<ref>{{Cite arXiv|last1=Regier|first1=Jeffrey|last2=Pamnany|first2=Kiran|last3=Giordano|first3=Ryan|last4=Thomas|first4=Rollin|last5=Schlegel|first5=David|last6=McAulife|first6=Jon|last7=Prabat|title=Learning an Astronomical Catalog of the Visible Universe through Scalable Bayesian Inference|eprint=1611.03404|class=cs.DC|year=2016}}</ref> used Julia to achieve \"peak performance of 1.54&nbsp;[[FLOPS|petaFLOPS]] using 1.3 million threads\"<ref>{{Cite press release|url=https://juliacomputing.com/press/2017/09/12/julia-joins-petaflop-club.html |title=Julia Joins Petaflop Club |date=12 September 2017 | first=Andrew |last=Claster |work=Julia Computing |quote=Celeste is written entirely in Julia, and the Celeste team loaded an aggregate of 178 terabytes of image data to produce the most accurate catalog of 188 million [[astronomical object]]s in just 14.6 minutes [..] a performance improvement of 1,000x in single-threaded execution.}}</ref> on 9300 <!-- on 9,300 (vs. 8192 Xeon cores\") possibly \"optional nVidia\" GPU cards of Cori are used (or not), unclear conflated with lower numbers? --> [[Knights Landing (microarchitecture)|Knights Landing]] (KNL) nodes of the [[Cray XC40#United States|Cori II (Cray XC40)]] supercomputer (then 6th fastest computer in the world).<ref>{{Cite web|url=https://twitter.com/Viral_B_Shah/status/930928375400751105|title=. @KenoFischer is speaking on Celeste in the @Intel theatre at @Supercomputing. 0.65M cores, 56 TB of data, Cori - world's 6th largest supecomputer.pic.twitter.com/21nLHo1qty|last=Shah|first=Viral B.|date=2017-11-15|website=@Viral_B_Shah|language=en|access-date=2019-09-15}}</ref> Julia thus joins C, C++, and Fortran as high-level languages in which petaFLOPS computations have been achieved.\n\nThree of the Julia co-creators are the recipients of the 2019 [[J. H. Wilkinson Prize for Numerical Software|James H. Wilkinson Prize for Numerical Software]] (awarded every four years) \"for the creation of Julia, an innovative environment for the creation of high-performance tools that enable the analysis and solution of computational science problems.\"<ref>{{Cite web|url=https://news.mit.edu/2018/julia-language-co-creators-win-james-wilkinson-prize-numerical-software-1226|title=Julia language co-creators win James H. Wilkinson Prize for Numerical Software|website=MIT News|access-date=2019-01-22}}</ref>  Also, Alan Edelman, professor of applied mathematics at MIT, has been selected to receive the 2019 IEEE Computer Society Sidney Fernbach Award \"for outstanding breakthroughs in high-performance computing, linear algebra, and computational science and for contributions to the Julia programming language.\"<ref>{{Cite press release|url=https://www.computer.org/press-room/2019-news/2019-ieee-fernbach-award-edelman|title=Alan Edelman of MIT Recognized with Prestigious 2019 IEEE Computer Society Sidney Fernbach Award {{!}} IEEE Computer Society|language=en-US|date=1 October 2019|access-date=2019-10-09}}</ref>\n\nJulia Computing and [[NVIDIA]] announce \"the availability of the Julia programming language as a pre-packaged container on the NVIDIA GPU Cloud (NGC) container registry\"<ref name=\"Julia_Nvidia\">{{Cite web|url=https://juliacomputing.com/blog/2019/12/03/nvidia-ngc-arm.html|title=Julia Computing and NVIDIA Bring Julia GPU Computing to Arm|date=2019-12-03|website=juliacomputing.com|access-date=2019-12-03}}</ref> with NVIDIA stating \"Easily Deploy Julia on x86 and Arm [..] Julia offers a package for a comprehensive HPC ecosystem covering machine learning, data science, various scientific domains and visualization.\"<ref>{{Cite web|url=https://blogs.nvidia.com/blog/2019/11/18/ngc-containers-arm/|title=NVIDIA Expands Support for Arm with HPC, AI, Visualization Containers on NGC {{!}} NVIDIA Blog|last=Patel|first=Chintan|date=2019-11-19|website=The Official NVIDIA Blog|language=en-US|access-date=2019-12-03}}</ref>\n\nAdditionally, \"Julia was selected by the [https://clima.caltech.edu/ Climate Modeling Alliance] as the sole implementation language for their next generation global climate model. This multi-million dollar project aims to build an earth-scale climate model providing insight into the effects and challenges of climate change.\"<ref name=\"Julia_Nvidia\"/>\n\n=== Sponsors ===\nJulia has received contributions from over 870 developers worldwide.<ref>{{Cite web|title=JuliaLang/julia: The Julia Language: A fresh approach to technical computing.|date=2019-01-26|url=https://github.com/JuliaLang/julia|publisher=The Julia Language|access-date=2019-01-26}}</ref> Dr. Jeremy Kepner at [[MIT Lincoln Laboratory]] was the founding sponsor of the Julia project in its early days. In addition, funds from the [[Gordon and Betty Moore Foundation]], the [[Alfred P. Sloan Foundation]], [[Intel]], and agencies such as [[National Science Foundation|NSF]], [[DARPA]], [[National Institutes of Health|NIH]], [[NASA]], and [[Federal Aviation Administration|FAA]] have been essential to the development of Julia.<ref>{{Cite web|url=https://julialang.org/research/|title=The Julia Language|website=julialang.org|access-date=2019-09-22}}</ref> [[Mozilla]], the maker of Firefox Web browser, with its research grants for H1 2019, sponsored \"a member of the official Julia team\" for the project \"Bringing Julia to the Browser\",<ref>{{Cite web|url=https://www.zdnet.com/article/mozilla-is-funding-a-way-to-support-julia-in-firefox/|title=Mozilla is funding a way to support Julia in Firefox|last=Cimpanu|first=Catalin|website=ZDNet|language=en|access-date=2019-09-22}}</ref> meaning to Firefox <!-- \"and the general browser environment--> and other web browsers.<ref>{{Cite web|url=https://alpha.iodide.io/notebooks/225/|title=Julia in Iodide|website=alpha.iodide.io|access-date=2019-09-22}}</ref><ref>{{Cite web|url=https://iodide-project.github.io/docs/language_plugins/|title=Language plugins - Iodide Documentation|website=iodide-project.github.io|access-date=2019-09-22}}</ref><ref>{{Cite web|url=https://mozilla-research.forms.fm/mozilla-research-grants-2019h1/forms/6510|title=Mozilla Research Grants 2019H1|website=Mozilla|language=en|quote=running language interpreters in WebAssembly. To further increase access to leading data science tools, we\u2019re looking for someone to port R or Julia to WebAssembly and to attempt to provide a level 3 language plugin for Iodide: automatic conversion of data basic types between R/Julia and Javascript, and the ability to share class instances between R/Julia and Javascript.|access-date=2019-09-22}}</ref><ref>{{Cite web|title=Literate scientific computing and communication for the web: iodide-project/iodide|date=2019-09-20|url=https://github.com/iodide-project/iodide|publisher=iodide|quote=We envision a future workflow that allows you to do your data munging in Python, fit a quick model in R or JAGS, solve some differential equations in Julia, and then display your results with a live interactive d3+JavaScript visualization&nbsp;... and all that within within a single, portable, sharable, and hackable file.|access-date=2019-09-22}}</ref>\n\n===Julia Computing===\nJulia Computing, Inc. was founded in 2015 by [[Viral B. Shah]], Deepak Vinchhi, [[Alan Edelman]], Jeff Bezanson, [[Stefan Karpinski]] and Keno Fischer.<ref>{{Cite web|url=https://juliacomputing.com/about-us|title=About Us \u2013 Julia Computing|website=juliacomputing.com|access-date=2017-09-12}}</ref>\n\nIn June 2017, Julia Computing raised $4.6M in seed funding from [[General Catalyst]] and [[Founder Collective]].<ref>https://juliacomputing.com/communication/2017/06/19/seed-funding.html</ref>\n\n==Language features==\nThough designed for numerical computing, Julia is a [[general-purpose programming language]].<ref>{{cite web\n  | title      = The Julia Language\n  | type       = official website\n  | url        = https://julialang.org/\n  | quote      = General Purpose [..] Julia lets you write UIs, statically compile your code, or even deploy it on a webserver.\n}}</ref>\nIt is also useful for low-level [[system programming|systems programming]],<ref name=\"LowLevelSystemsProgrammingInJulia\">{{cite web |url=http://juliacon.org/2018/talks_workshops/42/\n|archiveurl=https://web.archive.org/web/20181105083419/http://juliacon.org/2018/talks_workshops/42/\n|archivedate=5 November 2018\n|first=Todd |last=Green\n|title=Low-Level Systems Programming in High-Level Julia\n|date=10 August 2018\n|accessdate=5 November 2018\n}}</ref> as a [[specification language]],<ref name=\"spec\">{{cite web |url=http://juliacon.org/talks.html#friday\n|archiveurl=https://web.archive.org/web/20150701182804/http://juliacon.org/talks.html\n|archivedate=1 July 2015\n|first=Robert |last=Moss\n|title=Using Julia as a Specification Language for the Next-Generation Airborne Collision Avoidance System\n|quote=[[Airborne collision avoidance system]]\n|date=26 June 2015\n|accessdate=29 June 2015\n}}</ref> and for web programming at both server<ref>{{Cite web|url=https://medium.com/@richardanaya/how-to-create-a-multi-threaded-http-server-in-julia-ca12dca09c35|title=How to create a multi-threaded HTTP server in Julia|last=Anaya|first=Richard|date=2019-04-28|website=Medium|language=en|access-date=2019-07-25|quote=In summary, even though Julia lacks a multi-threaded server solution currently out of box, we can easily take advantage of its process distribution features and a highly popular load balancing tech to get full CPU utilization for HTTP handling.}}</ref><ref>{{Cite web|last=Anthoff|first=David|title=Node.js installation for julia|date=2019-06-01|url=https://github.com/davidanthoff/NodeJS.jl|access-date=2019-07-25}}</ref><!--<ref name=\"node-js\">{{cite web|url=https://node-julia.readme.io/|title=Getting Started with Node Julia \u00b7 Node Julia|date=|website=Node-julia.readme.io|accessdate=2017-05-31}}</ref> --> and client<ref name=\"JSExpr\"/><ref name=\"WebAssembly\"/> side.\n\nAccording to the official website, the main features of the language are:\n\n* [[Multiple dispatch]]: providing ability to define function behavior across many combinations of argument types\n* [[Dynamic type]] system: types for documentation, optimization, and dispatch\n* Good performance, approaching that of [[Type system|statically-typed]] languages like C\n* A built-in [[package manager]]\n* [[Lisp (programming language)|Lisp]]-like macros and other [[metaprogramming]] facilities\n* Call [[Python (programming language)|Python]] functions: use the PyCall package{{Efn|For calling the newer [[Python 3]] (the older default to call Python 2, is also still supported)<ref>{{cite web |url=https://github.com/JuliaPy/PyCall.jl |title=PyCall.jl |work=stevengj |publisher=github.com}}</ref><ref>{{cite newsgroup |url=https://groups.google.com/forum/#!topic/julia-users/lDM7-YXT2LU |title=Using PyCall in julia on Ubuntu with python3 |work=julia-users at Google Groups|quote=to import modules (e.g., python3-numpy)}}</ref> <!--([[PyPy]] and e.g. [[PHP]] was/is supported<ref name=\"Polyglot\">{{cite web|url=https://gitlab.com/wavexx/Polyglot.jl|title=wavexx / Polyglot.jl|website=GitLab|language=en|access-date=2019-07-25}}</ref> for Julia 0.5 (PyPy should work; supported by python-bond that Polyglot.jl is based on); [[Jython]] support is not confirmed, but since JavaCall.jl allows calling Java (and thus Scala) I assume also Jython.)--> and calling in the other direction, from Python to Julia, is also supported with ''pyjulia''.<ref>{{cite web |url=https://github.com/JuliaPy/pyjulia |title=python interface to julia}}</ref> \n<!--\nIt is not like Polyglot. jl does not support this for older Julia (and also interesting project to support other languages, e.g., PHP), but it has not been upgraded for Julia 1.0: Even calling [[recursive]]ly (back and forth) between these languages is possible, without (or with) using ''Polyglot.jl'',<ref name=\"Polyglot\"/> that supports additional languages to Python. \n-->\n\n}}\n* Call [[C (programming language)|C]] functions directly: no wrappers or special [[application programming interface|APIs]]\n* Powerful [[shell (computing)|shell]]-like abilities to manage other processes\n* Designed for [[Parallel computing|parallel]] and [[distributed computing]]\n* [[Coroutine|Coroutines]]: lightweight [[Green threads|''green'' threading]]\n* User-defined types are as fast and compact as built-ins\n* Automatic generation of efficient, specialized code for different argument types\n* Elegant and extensible conversions and promotions for numeric and other types\n* Efficient support for [[Unicode]], including but not limited to [[UTF-8]]\n<!-- |source=JuliaLang.org}} Only part missing it the MIT part, that is better explained elsewhere.-->\n\nMultiple dispatch (also termed [[multimethod]]s in Lisp) is a [[generalization]] of [[single dispatch]]&nbsp;\u2014 the [[Polymorphism (computer science)|polymorphic mechanism]] used in common [[object-oriented programming]] (OOP) languages&nbsp;\u2014 that uses [[Inheritance (object-oriented programming)|inheritance]]. In Julia, all concrete types are [[subtyping|subtypes]] of abstract types, directly or indirectly subtypes of the ''Any'' type, which is the top of the type hierarchy. Concrete types can not themselves be subtyped the way they can in other languages; composition is used instead (see also [[Inheritance (object-oriented programming)#Inheritance vs subtyping|inheritance vs subtyping]]).\n\nJulia draws significant inspiration from various dialects of Lisp<!-- Karpinski: \"In short, I would describe it as a Lisp with Matlab-like syntax\" https://www.reddit.com/r/programming/comments/pv3k9/why_we_created_julia_a_new_programming_language/ -->, including [[Scheme (programming language)|Scheme]] and [[Common Lisp]], and it shares many features with [[Dylan (programming language)|Dylan]], also a multiple-dispatch-oriented dynamic language (which features an [[ALGOL]]-like [[Free-form language|free-form]] [[Infix notation|infix]] syntax rather than a Lisp-like prefix syntax, while in Julia \"everything\"<ref name=\"Learn Julia in Y\">{{cite web|url=https://learnxinyminutes.com/docs/julia/ |title=Learn Julia in Y Minutes |website=Learnxinyminutes.com |date= |accessdate=2017-05-31}}</ref> is an [[Expression (computer science)|expression]]), and with [[Fortress (programming language)|Fortress]], another numerical programming language (which features multiple dispatch and a sophisticated parametric type system). While [[Common Lisp Object System]] (CLOS) adds multiple dispatch to Common Lisp, not all functions are generic functions.\n\nIn Julia, Dylan, and Fortress extensibility is the default, and the system's built-in functions are all generic and extensible. In Dylan, multiple dispatch is as fundamental as it is in Julia: all user-defined functions and even basic built-in operations like <code>+</code> are generic. Dylan's type system, however, does not fully support parametric types, which are more typical of the [[Generational list of programming languages#ML based|ML lineage of languages]]. By default, CLOS does not allow for dispatch on Common Lisp's parametric types; such extended dispatch semantics can only be added as an extension through the [[Common Lisp Object System#Metaobject Protocol|CLOS Metaobject Protocol]]. By convergent design, Fortress also features multiple dispatch on parametric types; unlike Julia, however, Fortress is statically rather than dynamically typed, with separate compiling and executing phases. The language features are summarized in the following table:\n\n{| class=\"wikitable\"\n|-\n! [[Programming language|Language]] !! [[Type system]] !! [[Generic function]]s !! [[Parametric polymorphism|Parametric types]]\n|-\n| Julia || Dynamic || Default || Yes\n|-\n| [[Common Lisp]] || Dynamic || Opt-in || Yes (but no dispatch)\n|-\n| [[Dylan (programming language)|Dylan]] || Dynamic || Default || Partial (no dispatch)\n|-\n| [[Fortress (programming language)|Fortress]] || Static || Default || Yes\n|}\n\nBy default, the Julia runtime must be pre-installed as user-provided source code is run. Alternatively, a standalone [[executable]] that needs no Julia source code can be built with ''ApplicationBuilder.jl''<ref>{{Cite web|last=Daly|first=Nathan|title=GitHub - NHDaly/ApplicationBuilder.jl: Compile, bundle, and release julia software.|date=2019-02-13|url=https://github.com/NHDaly/ApplicationBuilder.jl|access-date=2019-02-15}}</ref> and ''PackageCompiler.jl''.<ref>{{cite web|title=GitHub - JuliaLang/PackageCompiler.jl: Compile your Julia Package.|date=2019-02-14|url=https://github.com/JuliaLang/PackageCompiler.jl|publisher=The Julia Language|access-date=2019-02-15}}</ref><!--\n<ref>{{cite web |url=https://github.com/dhoegh/BuildExecutable.jl |title=Build a standalone executables from a Julia script}}</ref><ref>{{cite newsgroup|url=https://groups.google.com/forum/#!topic/julia-users/MtF4wHc77sw |title=.jl to .exe |website=Groups.google.com |date= |accessdate=2017-05-31}}</ref>  -->\n\nJulia's [[Macro (computer science)#Syntactic macros|syntactic macros]] (used for [[metaprogramming]]), like Lisp macros, are more powerful than [[Macro (computer science)#Text-substitution macros|text-substitution macros]] used in the [[preprocessor]] of some other languages such as C, because they work at the level of [[abstract syntax tree]]s (ASTs). Julia's macro system is [[hygienic macro|hygienic]], but also supports deliberate capture when desired (like for [[anaphoric macro]]s) using the <code>esc</code> construct.\n\n==Interaction==\nThe Julia official distribution includes a \"full-featured interactive command-line REPL\" ([[read\u2013eval\u2013print loop]]),<ref>{{Cite web|url=https://docs.julialang.org/en/v1/stdlib/REPL/|title=The Julia REPL \u00b7 The Julia Language|website=docs.julialang.org|access-date=2019-09-22}}</ref> with a searchable history, [[tab-completion]], many helpful keybindings, and dedicated help and [[shell (computing)|shell]] modes;<ref>{{Cite web|url=https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL|title=Introducing Julia/The REPL - Wikibooks, open books for an open world|website=en.wikibooks.org|quote=you can install the Julia package OhMyREPL.jl (https://github.com/KristofferC/OhMyREPL.jl) which lets you customize the REPL's appearance and behaviour|access-date=2019-09-22}}</ref> which can be used to experiment and test code quickly.<ref>{{Cite web|url=https://docs.julialang.org/en/v1/manual/getting-started/|title=Getting Started \u00b7 The Julia Language|website=docs.julialang.org|language=en|access-date=2018-08-15}}</ref> The following fragment represents a sample session example where strings are concatenated automatically by println:<ref>See also: https://docs.julialang.org/en/v1/manual/strings/ for string interpolation and the <code>string(greet, \", \", whom, \".\\n\")</code> example for preferred ways to concatenate strings. <!--While the <code>+</code> operator is not used for string concatenation, it could easily be defined to do so.--> Julia has the println and print functions, but also a @printf macro (i.e., not in function form) to eliminate run-time overhead of formatting (unlike the same function in C).</ref>\n\n<source lang=\"jlcon\">\njulia> p(x) = 2x^2 + 1; f(x, y) = 1 + 2p(x)y\njulia> println(\"Hello world!\", \" I'm on cloud \", f(0, 4), \" as Julia supports recognizable syntax!\")\nHello world! I'm on cloud 9 as Julia supports recognizable syntax!\n</source>\n\nThe REPL gives user access to the system shell and to help mode, by pressing <code>;</code> or <code>?</code> after the prompt (preceding each command), respectively. It also keeps the history of commands, including between sessions.<ref>{{cite web|title=Julia Documentation|url=https://docs.julialang.org|website=JuliaLang.org|accessdate=18 November 2014}}</ref> Code that can be tested inside the Julia's interactive section or saved into a file with a <code>.jl</code> extension and run from the command line by typing:<ref name=\"Learn Julia in Y\"/>\n\n<source lang=\"console\">\n $ julia <filename>\n</source>\n\nJulia is supported by [[Jupyter]], an online interactive \"notebooks\" environment.<ref>{{cite web |url=https://jupyter.org/ |title=Project Jupyter}}</ref>\n\n=== Use with other languages ===\nJulia is in practice [[interoperability|interoperable]] with many languages. Julia's <source lang=\"julia\" inline>ccall</source> keyword is used to call C-exported or Fortran shared library functions individually.\n\nJulia has support for [[Unicode 12.1]] (support for current Unicode 13.0 has been implemented<ref>{{Cite web|url=https://github.com/JuliaStrings/utf8proc/pull/179|title=Unicode 13 support by stevengj \u00b7 Pull Request #179 \u00b7 JuliaStrings/utf8proc|website=GitHub|language=en|access-date=2020-03-29}}</ref> for Julia 1.5), which added only one letter since Unicode 12.0,<ref>{{Cite web|url=https://github.com/JuliaLang/julia/pull/32002|title=support for Unicode 12.1.0 by stevengj \u00b7 Pull Request #32002 \u00b7 JuliaLang/julia|website=GitHub|language=en|access-date=2019-05-12}}</ref> with [[UTF-8]] used for strings (by default) and for Julia source code (only allowing legal UTF-8 in the latest version), meaning also allowing as an option common math symbols for many operators, such as \u2208 for the <code>in</code> operator.\n\nJulia has packages supporting markup languages such as [[HTML]] (and also for [[HTTP]]), [[XML]], [[JSON]] and [[BSON]], and for [[database]]s and Web use in general.\n\n== Usage ==\nLibraries such as [[Flux (machine-learning framework)|Flux]] and [[Knet (machine-learning framework)|Knet]] implement complete machine-learning frameworks written completely in Julia. [[Apache MXNet]] and [[TensorFlow]] are also available through wrapper libraries. [[Turing (probabilistic programming)|Turing]] and [[Gen (probabilistic programming)|Gen]] implement general-purpose [[probabilistic programming]] languages into Julia. [[Pharmacokinetics|Pharmacokinetic]] modeling and simulations are made available through the [[Pumas (pharmaceutical modeling)|Pumas]] suite.\n\n==Implementation==\nJulia's core is implemented in Julia and [[C (programming language)|C]]<!--C99, except for 0.4 needing C11 because of static asserts-->, together with [[C++]] for the [[LLVM]] dependency. The parsing and code-lowering are implemented in FemtoLisp, a [[Scheme (programming language)|Scheme]] dialect.<ref name=\"JeffBezanson 2019\">{{cite web | author=JeffBezanson | title=JeffBezanson/femtolisp | website=GitHub | date=June 6, 2019 | url=https://github.com/JeffBezanson/femtolisp | access-date=June 16, 2019}}</ref> The LLVM compiler infrastructure project is used as the [[Compiler#Back end|back end]] for generation of [[64-bit computing|64-bit]] or [[32-bit]] optimized [[machine code]] depending on the platform Julia runs on. With some exceptions (e.g., [[PCRE]]), the [[standard library]] is implemented in Julia. The most notable aspect of Julia's implementation is its speed, which is often within a factor of two relative to fully optimized C code (and thus often an order of magnitude faster than Python or [[R (programming language)|R]]).<ref name=\"Julia-TR\">{{cite web\n  | format       = PDF\n  | title        = Julia: A Fast Dynamic Language for Technical Computing\n  | url          = https://julialang.org/images/julia-dynamic-2012-tr.pdf\n  | year         = 2012\n  }}</ref><ref>{{cite web\n  | title        = How To Make Python Run As Fast As Julia\n  | url          = https://www.ibm.com/developerworks/community/blogs/jfp/entry/Python_Meets_Julia_Micro_Performance?lang=en\n  | year         = 2015\n  }}</ref><ref>{{cite web\n  | title        = Basic Comparison of Python, Julia, R, Matlab and IDL\n  | url          = https://modelingguru.nasa.gov/docs/DOC-2625\n  | year         = 2015\n  }}</ref> Development of Julia began in 2009 and an [[Open-source software|open-source]] version was publicized in February 2012.<ref name=\"announcement\">{{cite web\n  | title        = Why We Created Julia\n  | date         = February 2012\n  | website      = Julia website\n  | url          = https://julialang.org/blog/2012/02/why-we-created-julia\n  | accessdate   = 7 February 2013\n  }}</ref><ref>{{cite web\n  | last         = Gibbs\n  | first        = Mark\n  | title        = Pure and Julia are cool languages worth checking out\n  | url          = https://www.networkworld.com/columnists/2013/010913-gearhead.html\n  | type         = column\n  | work         = Network World\n  | date         = 9 January 2013\n  | accessdate   = 7 February 2013\n}}</ref>\n\n===Current and future platforms===\nWhile Julia uses JIT,<!-- Viral states \"Julia no longer uses the MCJIT in LLVM\" so this link is probably misleading:\n<ref>{{cite web |url=https://github.com/JuliaLang/julia/pull/5208\n|title=Support MCJIT\n|website=Github.com\n|accessdate=26 May 2015\n}}</ref> --> Julia generates native machine code directly, before a function is first run (not [[bytecode]]s that are run on a [[virtual machine]] (VM) or translated as the bytecode is running, as with, ''e.g.'', Java; the [[JVM]] or [[Dalvik (software)|Dalvik]] in Android).\n\nJulia has four support tiers,<ref>{{cite web|url=https://julialang.org/downloads/#support-tiers|title=Julia Downloads|website=julialang.org|access-date=2019-05-17}}</ref> and currently supports all [[x86-64]] processors, that are [[64-bit computing|64-bit]] (and is more [[program optimization|optimized]] for the latest generations) and all [[IA-32]] (\"x86\") processors except for decades old ones, i.e., in [[32-bit]] mode (\"i686\", excepting CPUs from the pre-[[Pentium 4]]-era); and supports more in lower tiers, e.g., ARM has tier 2 support: Julia \"fully supports ARMv8 (AArch64) processors, and supports ARMv7 and ARMv6 (AArch32) with some caveats.\"<ref>{{cite web|title=julia/arm.md|date=2019-11-29|url=https://github.com/JuliaLang/julia/blob/master/doc/build/arm.md|publisher=The Julia Language|quote=A list of [https://github.com/JuliaLang/julia/labels/arm known issues] for ARM is available.|access-date=2019-11-29}}</ref> [[CUDA]] (i.e. Nvidia GPUs; implementing [[Parallel Thread Execution|PTX]]) has tier 1 support, with the help of an [https://github.com/JuliaGPU/CUDAnative.jl external package]. There are also additionally packages supporting other accelerators, such as Google's [[tensor processing unit|TPU]]s,<ref>{{Citation|title=Julia on TPUs|date=2019-11-26|url=https://github.com/JuliaTPU/XLA.jl|publisher=JuliaTPU|access-date=2019-11-29}}</ref> and AMD's GPUs also have support with e.g. [[OpenCL]]. Julia's downloads page provides [[executable]]s (and source) for all the officially supported platforms.\n\nOn some platforms, Julia may need to be compiled from [[source code]] (e.g., the original [[Raspberry Pi]]), with specific build options. Julia has been \"successfully built\" <!--on the following ARMv8 devices:\n\n* [https://www.nvidia.com/object/embedded-systems-dev-kits-modules.html nVidia Jetson TX1 & TX2];\n* [https://www.apm.com/products/data-center/x-gene-family/x-gene/ X-Gene 1];\n* [https://softiron.com/products/overdrive-3000/ Overdrive 3000];\n* [https://www.cavium.com/ThunderX_ARM_Processors.html Cavium ThunderX]-->\non several ARM platforms, up to, e.g., \"ARMv8 Data Center & Cloud Processors\", such as [https://www.cavium.com/ThunderX_ARM_Processors.html Cavium ThunderX] (first ARM with 48 cores). PowerPC (64-bit) has tier 3 support meaning \"may or may not build\".\n<!--\n Support for ARM, [[AArch64]], and [[Power Architecture|POWER8]] (little-endian) has been added recently as of 0.5.1 is available too.<ref>{{cite web|author= |url=https://github.com/JuliaLang/julia/blob/v0.5.2/README.md |title=julia/README.md at v0.5.2 \u00b7 JuliaLang/julia \u00b7 GitHub |website=Github.com |date=2017-05-03 |accessdate=2017-05-31}}</ref>\n\nand in 0.5.x:\n\n\"work in progress\" text dropped with (not yet backported (possibly the text, only docs left behind?) to 0.6.x): https://github.com/JuliaLang/julia/commit/dcffef03594779402bb5c2666fbcf24b4438adba#diff-8b8b297c5626992d7377a6bbb3aadceb\n\n\"only supports ARMv7\" text dropped on master (may apply on older, meaning possibly only for ARMv6?:\n\n\"[[Nightly build]]s are available for ARMv7-A. [..] Note that OpenBLAS only supports ARMv7. For older ARM variants, using the reference BLAS may be the simplest thing to do. [..] Note: These [Raspberry Pi] chips use ARMv6, which is not well supported at the moment. However it is possible to get a working Julia build. [e.g., supported] [[Tegra#Tegra P1|nVidia Jetson TX2]] [with] CUDA functionality\"<ref>{{cite web|author=JuliaLang |url=https://github.com/JuliaLang/julia/blob/v0.6.2/README.arm.md |title=julia/README.arm.md at v0.5.2 \u00b7 JuliaLang/julia \u00b7 GitHub |publisher=Github.com |date= |accessdate=2017-05-31}}</ref>\n\nThe [[Raspberry Pi]] support also includes limited support for [[Raspberry Pi]] 1 (since it has [[ARMv6]]),<ref>{{cite web |url=https://github.com/JuliaLang/julia/issues/10488\n|title=Cross-compiling for ARMv6\n|quote=I believe #10917 should fix this. The CPU used there <code>arm1176jzf-s</code>. Please reopen if it does not.\n|accessdate=16 May 2015}}\n</ref><ref>\n{{cite web |url=https://github.com/JuliaLang/julia/issues/10235\n|title=ARM build failing during bootstrap on Raspberry Pi 2\n|quote=I can confirm (FINALLY) that it works on the Raspberry Pi 2 [..] I guess we can announce alpha support for arm in 0.4 as well. |accessdate=16 May 2015}}</ref>\n\n-->\nJulia is now supported in [[Raspbian]]<ref>{{cite web |url=https://julialang.org/blog/2017/05/raspberry-pi-julia |title=Julia available in Raspbian on the Raspberry Pi |quote=Julia works on all the Pi variants, we recommend using the Pi 3.}}</ref> while support is better for newer Pis, e.g. those with ARMv7 or newer; the Julia support is promoted by the [[Raspberry Pi Foundation]].<ref>{{cite web |url=https://www.raspberrypi.org/blog/julia-language-raspberry-pi/ |title=Julia language for Raspberry Pi |work=[[Raspberry Pi Foundation]]}}</ref> There's also support for web browsers/[[JavaScript]] through JSExpr.jl;<ref name=\"JSExpr\">{{Cite web|title=Translate Julia to JavaScript |date=2019-07-07|url=https://github.com/JuliaGizmos/JSExpr.jl|publisher=JuliaGizmos|access-date=2019-07-25}}</ref> and the alternative language of web browsers, [[WebAssembly]], has support<ref name=\"WebAssembly\">{{Cite web|last=Fischer|first=Keno|title=Running julia on wasm|date=2019-07-22|url=https://github.com/Keno/julia-wasm|access-date=2019-07-25}}</ref> through minimal support in Julia, that supports several upcoming external Julia projects.\n<!--\nJulia supports [[64-bit computing|64-bit]] [[ARM architecture|ARM]] and [[PowerPC]] and \"fully supports [[ARMv8]] ([[AArch64]]) processors, and supports ARMv7 and ARMv6 (AArch32) with some caveats\"<ref>https://github.com/JuliaLang/julia/blob/master/README.arm.md</ref><ref>https://github.com/JuliaLang/julia/issues/10791#issuecomment-91735439</ref> and [[PowerPC]] being worked on, with almost no open specific issues,<ref>https://github.com/JuliaLang/julia/labels/Power</ref><ref>{{cite web |url=https://groups.google.com/forum/#!topic/julia-dev/BYVCyUlNR8c |title=Porting Julia to PowerPC |quote=Wow, the latest git allows me to build to completion. |accessdate=9 May 2015}}</ref> with [[Executable|binaries]] available for [[POWER7]] (\"due to some small support from [[IBM]]\") and [[POWER8]], that are expected to have official beta support as of 0.5 (at least for non-parallel support).<ref>{{cite web |url=https://groups.google.com/forum/#!topic/julia-users/xB0k7XMBNqM |title=IBM Power port |quote=I am hoping we can have beta support from the 0.5 release onwards for sequential julia. We were able to do this work due to some small support from IBM.}}</ref>\n-->\n<!--\nSupport for [[GNU/kFreeBSD]] and [[GNU Hurd]] is being worked on (in JuliaLang's [[C mathematical functions#libm|openlibm]] dependency project).<ref>{{cite web|url=https://github.com/JuliaLang/openlibm/pull/129 |title=Fix building tests on GNU/kFreeBSD and GNU/Hurd by ginggs \u00b7 Pull Request #129 \u00b7 JuliaLang/openlibm |website=Github.com |date= |accessdate=2017-05-31}}</ref>\nYes, openlibm, is not Julia, but is a dependency of it-->\n<!--\nAn unofficial Julia-lite,<ref>https://github.com/ScottPJones/julia/tree/spj/lite</ref>a trimmed down fork (by now outdated) is a available. Officially Julia has been dropping dependencies and features from the standard library, to make GPL-free (one left), so it's also the official plan.\n-->\nJulia can compile to ARM; thus, in theory, [[Android app]]s can be made, but for now only Julia (and most packages) has been made to run under [[Android (operating system)|Android]] indirectly, ''i.e.'', in Ubuntu on Android.<ref>{{Cite web|url=https://discourse.julialang.org/t/using-julia-on-android/8086/7|title=Using Julia on Android?|date=2019-09-27|website=JuliaLang|language=en-US|access-date=2019-10-02}}</ref>\n\n==See also==\n* [[Comparison of numerical analysis software]]\n* [[Comparison of statistical packages]]\n\n==Notes==\n{{Notelist|80em}}\n\n==References==\n{{Reflist|30em}}\n\n==Further reading==\n* {{cite book|last=Nagar|first=Sandeep|year=2017|title=Beginning Julia Programming-For Engineers and Scientists|publisher=Springer}}\n* {{cite journal|author1=Bezanson, J|author2=Edelman, A|author3=Karpinski, S|author4=Shah, V. B|year=2017|title=Julia: A fresh approach to numerical computing|publisher=SIAM Review |volume=59 |issue=1 |pages=65\u201398}}\n* {{cite book|last=Joshi|first=Anshul|year=2016|title=Julia for Data Science \uff0d Explore the world of data science from scratch with Julia by your side|publisher=Packt Publishing}}\n\n==External links==\n{{Wikibooks|Introducing Julia}}\n* {{Official website|https://julialang.org}}\n* [https://github.com/JuliaLang/julia Source code]\n\n{{Programming languages}}\n{{FOSS}}\n{{Numerical analysis software}}\n{{Mathematical optimization software}}\n{{Statistical software}}\n\n[[Category:2012 software]]\n[[Category:Array programming languages]]\n[[Category:Computational notebook]]\n[[Category:Cross-platform software]]\n[[Category:Data mining and machine learning software]]\n[[Category:Data-centric programming languages]]\n[[Category:Dynamically typed programming languages]]\n[[Category:Free compilers and interpreters]]<!-- note there's also a Julia interpreter (not on by default); beside FemptoLisp-->\n[[Category:Free computer libraries]]\n[[Category:Free data analysis software]]\n[[Category:Free data visualization software]]\n[[Category:Free software projects]]\n[[Category:Free software programmed in C]]\n[[Category:Free statistical software]]\n[[Category:Functional languages]]\n[[Category:High-level programming languages]]\n[[Category:Lisp programming language_family]]\n[[Category:Multi-paradigm programming languages]]<!-- ok? Mostly only using the main paradigm multiple-dispatch, but Julia enables using more, e.g. implementing class-based OO-->\n[[Category:Numerical analysis software for Linux]]\n[[Category:Numerical analysis software for MacOS]]\n[[Category:Numerical analysis software for Windows]]\n[[Category:Numerical libraries]] <!--for Julia's standard library: seems ok, as e.g. part of (and all planned) C's libm has been rewritten in Julia-->\n[[Category:Numerical linear algebra]]\n[[Category:Numerical programming languages]]\n[[Category:Object-oriented programming languages]]\n[[Category:Parallel computing]]\n[[Category:Procedural programming languages]]\n[[Category:Programming languages]]\n[[Category:Programming languages created in 2012]]\n[[Category:Software using the MIT license]]\n<!-- [[Category:Scripting languages]] ? -->\n[[Category:Statistical programming languages]]\n[[Category:Text-oriented programming languages]]\n[[Category:Homoiconic programming languages]]\n[[Category:Articles with example Julia code]]\n[[Category:Free software programmed in Julia]] <!-- Julia is written, mostly, in Julia -->\n", "name_user": "Hydrargyrum", "label": "safe", "comment": "\u2192\u200eCurrent and future platforms", "url_page": "//en.wikipedia.org/wiki/Julia_(programming_language)"}
