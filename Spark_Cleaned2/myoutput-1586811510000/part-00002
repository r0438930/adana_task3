{"title_page": "Common Intermediate Language", "text_new": "{{short description|Intermediate representation defined within the CLI specification}}\n{{confused|C Intermediate Language}}\n{{refimprove|date=November 2017}}\n'''Common Intermediate Language''' ('''CIL'''), formerly called '''Microsoft Intermediate Language''' ('''MSIL''') or '''Intermediate Language''' ('''IL'''),<ref>{{cite web |url = https://docs.microsoft.com/en-us/dotnet/standard/managed-code |title = Intermediate Language & execution}}</ref> is the [[intermediate language]] binary instruction set defined within the [[Common Language Infrastructure]] (CLI) specification.<ref>{{cite web |url = https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf |page = 32 |title = ECMA-335 Common Language Infrastructure (CLI)}}</ref> CIL instructions are executed by a CLI-compatible runtime environment such as the [[Common Language Runtime]]. Languages which target the CLI compile to CIL. CIL is [[object-oriented]], [[Stack machine|stack-based]] [[bytecode]]. Runtimes typically [[Just-in-time compilation|just-in-time]] compile CIL instructions into [[native code]].\n\nCIL was originally known as Microsoft Intermediate Language (MSIL) during the beta releases of the .NET languages. Due to standardization of [[C Sharp (programming language)|C#]] and the CLI, the bytecode is now officially known as CIL.<ref>{{cite web\n| url = http://www.interviewcity.com/2010/04/what-is-intermediate-languageilmsilcil.html\n| title = What is Intermediate Language(IL)/MSIL/CIL in .NET \n| accessdate = 2011-02-17\n| quote = CIL: ... When we compile [a] .NET project, it [is] not directly converted to binary code but to the intermediate language. When a project is run, every language of .NET programming is converted into binary code into CIL. Only some part of CIL that is required at run time is converted into binary code. DLL and EXE of .NET are also in CIL form.}}</ref> [[Windows Defender]] virus definitions continue to refer to binaries compiled with it as MSIL.<ref name=\"Defender\">{{cite web |title=HackTool:MSIL/SkypeCracker |url=https://www.microsoft.com/en-us/wdsi/threats/malware-encyclopedia-description?Name=HackTool:MSIL/SkypeCracker&threatId=-2147221892 |publisher=Microsoft |accessdate=26 November 2019}}</ref>\n\n==General information==\nDuring compilation of [[List of CLI languages|CLI programming languages]], the [[source code]] is translated into CIL code rather than into platform- or processor-specific [[object file|object code]]. CIL is a [[CPU]]- and platform-independent instruction set that can be executed in any environment supporting the Common Language Infrastructure,<ref>\n{{cite book\n| url = https://books.google.com/books?id=VGT1_UJzjM0C&pg=PA15&lpg=PA15&dq=CIL+is+platform-independent#v=onepage&q=CIL%20is%20platform-independent&f=false\n| title = Benefits of CIL\n| accessdate = 2011-02-17\n| quote = Furthermore, given that CIL is platform-agnostic, .NET itself is platform-agnostic...| isbn = 9781590598849\n| last1 = Troelsen\n| first1 = Andrew\n| date = 2009-05-28\n}}\n</ref> such as the [[Common Language Runtime|.NET runtime]] on [[Microsoft Windows|Windows]], or the [[cross-platform]] [[Mono (software)|Mono]] runtime. In theory, this eliminates the need to distribute different executable files for different platforms and CPU types. CIL code is verified for safety during runtime, providing better security and reliability than natively compiled executable files.\n\nThe execution process looks like this:\n\n#Source code is converted to CIL [[bytecode]] and a [[Assembly (CLI)|CLI assembly]] is created.\n#Upon execution of a CIL assembly, its code is passed through the runtime's [[Just-in-time compilation|JIT compiler]] to generate native code. Ahead-of-time compilation may also be used, which eliminates this step, but at the cost of executable-file portability.\n#The computer's processor executes the native code.\n\n==Instructions==\n{{See also|List of CIL instructions}}\n\nCIL bytecode has [[instruction (computer science)|instruction]]s for the following groups of tasks:\n*Load and store\n*[[Arithmetic]]\n*[[Type conversion]]\n*[[Dynamic memory allocation|Object creation and manipulation]]\n*[[stack (data structure)|Operand stack management (push / pop)]]\n*[[branch (computer science)|Control transfer (branching)]]\n*[[Subroutine|Method invocation and return]]\n*[[Exception handling|Throwing exceptions]]\n*[[Monitor (synchronization)|Monitor-based concurrency]]\n*Data and function pointers manipulation needed for C++/CLI and unsafe C# code\n\n==Computational model==\nThe Common Intermediate Language is object-oriented and [[stack-based]]. That means that data is pushed on a stack instead of pulled from registers as in most [[CPU architecture]]s.\n\nIn [[x86]] it might look like this:\n<syntaxhighlight lang=\"asm\">\nadd eax, edx\n</syntaxhighlight>\n\nThe corresponding code in [[Intermediate language|IL]] can be rendered as this, where 0 is eax and 1 is edx:\n<syntaxhighlight lang=\"csharp\">\nldloc.0    // push local variable 0 onto stack\nldloc.1    // push local variable 1 onto stack\nadd        // pop and add the top two stack items then push the result onto the stack\nstloc.0    // pop and store the top stack item to local variable 0\n</syntaxhighlight>\n\nHere are two locals that are pushed on the stack. When the add-instruction is called the operands get popped and the result is pushed. The remaining value is then popped and stored in the first local.\n\n===Object-oriented concepts===\nThis extends to object-oriented concepts as well. You may create objects, call methods and use other types of members such as fields.\n\nCIL is designed to be object-oriented and every [[Method (programming)|method]] needs (with some exceptions) to reside in a class. So does this static method:\n<syntaxhighlight lang=\"csharp\">\n.class public Foo\n{\n    .method public static int32 Add(int32, int32) cil managed\n    {\n        .maxstack 2\n        ldarg.0 // load the first argument;\n        ldarg.1 // load the second argument;\n        add     // add them;\n        ret     // return the result;\n    }\n}\n</syntaxhighlight>\n\nThis method does not require any instance of Foo to be declared because it is static. That means it belongs to the class and it may then be used like this in C#:\n<syntaxhighlight lang=\"csharp\">\nint r = Foo.Add(2, 3);    // 5\n</syntaxhighlight>\n\nIn CIL:\n<syntaxhighlight lang=\"csharp\">\nldc.i4.2\nldc.i4.3\ncall int32 Foo::Add(int32, int32)\nstloc.0\n</syntaxhighlight>\n\n====Instance classes====\n\nAn instance class contains at least one constructor and some instance members. This class has a set of methods representing actions of a Car-object.\n<syntaxhighlight lang=\"csharp\">\n.class public Car\n{\n    .method public specialname rtspecialname instance void .ctor(int32, int32) cil managed\n    {\n        /* Constructor */\n    }\n\n    .method public void Move(int32) cil managed\n    {\n        /* Omitting implementation */\n    }\n\n    .method public void TurnRight() cil managed\n    {\n        /* Omitting implementation */\n    }\n\n    .method public void TurnLeft() cil managed\n    {\n        /* Omitting implementation */\n    }\n\n    .method public void Brake() cil managed\n    {\n        /* Omitting implementation */\n    }\n}\n</syntaxhighlight>\n\n====Creating objects====\n\nIn C# class instances are created like this:\n<syntaxhighlight lang=\"csharp\">\nCar myCar = new Car(1, 4); \nCar yourCar = new Car(1, 3); \n</syntaxhighlight>\n\nAnd these statements are roughly the same as these instructions:\n<syntaxhighlight lang=\"csharp\">\nldc.i4.1\nldc.i4.4\nnewobj instance void Car::.ctor(int, int)\nstloc.0    // myCar = new Car(1, 4);\nldc.i4.1\nldc.i4.3\nnewobj instance void Car::.ctor(int, int)\nstloc.1    // yourCar = new Car(1, 3);\n</syntaxhighlight>\n\n====Invoking instance methods====\n\nInstance methods are invoked like the one that follows:\n<syntaxhighlight lang=\"csharp\">\nmyCar.Move(3);\n</syntaxhighlight>\n\nIn CIL:\n<syntaxhighlight lang=\"csharp\">\nldloc.0    // Load the object \"myCar\" on the stack\nldc.i4.3\ncall instance void Car::Move(int32)\n</syntaxhighlight>\n\n===Metadata===\n{{Main|Metadata (CLI)}}\nCLI records information about compiled classes as [[Metadata]]. Like the type library in the [[Component Object Model]], this enables applications to support and discover the interfaces, classes, types, methods, and fields in the assembly. The process of reading such metadata is called ''[[Reflection (computer science)|reflection]]''.\n\nMetadata can be data in the form of '' attributes''. Attributes can be custom made by extending from the <code>Attribute</code> class. This is a very powerful feature. It allows the creator of the class the ability to adorn it with extra information that consumers of the class can use in various meaningful ways depending on the application domain.\n\n==Example==\nBelow is a basic [[Hello, World]] program written in CIL. It will display the string \"Hello, world!\".\n<syntaxhighlight lang=\"csharp\">\n.assembly Hello {}\n.assembly extern mscorlib {}\n.method static void Main()\n{\n    .entrypoint\n    .maxstack 1\n    ldstr \"Hello, world!\"\n    call void [mscorlib]System.Console::WriteLine(string)\n    ret\n}\n</syntaxhighlight>\n\nThe following code is more complex in number of opcodes.\n\n''This code can also be compared with the corresponding code in the article about [[Java bytecode]].''\n<syntaxhighlight lang=\"csharp\">\nstatic void Main(string[] args)\n{\n    for (int i = 2; i < 1000; i++)\n    {\n        for (int j = 2; j < i; j++)\n        {\n             if (i % j == 0)\n                 goto outer;\n        }\n        Console.WriteLine(i);\n        outer:;\n    }\n}\n</syntaxhighlight>\n\nIn CIL syntax it looks like this:\n<syntaxhighlight lang=\"cpp\">\n.method private hidebysig static void Main(string[] args) cil managed\n{\n    .entrypoint\n    .maxstack  2\n    .locals init (int32 V_0,\n                  int32 V_1)\n\n              ldc.i4.2\n              stloc.0\n              br.s       IL_001f\n    IL_0004:  ldc.i4.2\n              stloc.1\n              br.s       IL_0011\n    IL_0008:  ldloc.0\n              ldloc.1\n              rem\n              brfalse.s  IL_001b\n              ldloc.1\n              ldc.i4.1\n              add\n              stloc.1\n    IL_0011:  ldloc.1\n              ldloc.0\n              blt.s      IL_0008\n              ldloc.0\n              call       void [mscorlib]System.Console::WriteLine(int32)\n    IL_001b:  ldloc.0\n              ldc.i4.1\n              add\n              stloc.0\n    IL_001f:  ldloc.0\n              ldc.i4     0x3e8\n              blt.s      IL_0004\n              ret\n}\n</syntaxhighlight>\n\nThis is just a representation of how CIL looks like near VM-level. When compiled the methods are stored in tables and the instructions are stored as bytes inside the assembly, which is a [[Portable Executable]] (PE).\n\n==Generation==\nA CIL assembly and instructions are generated by either a compiler or a utility called the ''IL Assembler'' ([[ILAsm]]) that is shipped with the execution environment.\n\nAssembled CIL can also be disassembled into code again using the ''IL Disassembler'' (ILDASM). There are other tools such as [[.NET Reflector]] that can decompile CIL into a high-level language (e.&nbsp;g. C# or [[Visual Basic .NET|Visual Basic]]). This makes CIL a very easy target for reverse engineering. This trait is shared with [[Java bytecode]]. However, there are tools that can [[Obfuscated code|obfuscate]] the code, and do it so that the code cannot be easily readable but still be runnable.\n\n==Execution==\n\n===Just-in-time compilation===\n[[Just-in-time compilation]] (JIT) involves turning the byte-code into code immediately executable by the CPU. The conversion is performed gradually during the program's execution. JIT compilation provides environment-specific optimization, runtime type safety, and assembly verification. To accomplish this, the JIT compiler examines the assembly metadata for any illegal accesses and handles violations appropriately.\n\n===Ahead-of-time compilation===\n[[Common Language Infrastructure|CLI]]-compatible execution environments also come with the option to do an [[Ahead-of-time compilation]] (AOT) of an assembly to make it execute faster by removing the JIT process at runtime.\n\nIn the [[.NET Framework]] there is a special tool called the [[Native Image Generator]] (NGEN) that performs the AOT. A different approach for AOT is [[CoreRT]] that allows the compilation of .Net Core code to a single executable with no dependency on a runtime. In [[Mono (programming)|Mono]] there is also an option to do an AOT.\n\n==Pointer instructions - C++/CLI==\nA notable difference from Java's bytecode is that CIL comes with ldind, stind, ldloca, and many call instructions which are enough for data/function pointers manipulation needed to compile C/C++ code into CIL.\n\n<syntaxhighlight lang=\"cpp\">\nclass A {\n   public: virtual void __stdcall meth() {}\n};\nvoid test_pointer_operations(int param) {\n\tint k = 0;\n\tint * ptr = &k;\n\t*ptr = 1;\n\tptr = &param;\n\t*ptr = 2;\n\tA a;\n\tA * ptra = &a;\n\tptra->meth();\n}\n</syntaxhighlight>\n\nThe corresponding code in CIL can be rendered as this:\n\n<syntaxhighlight lang=\"cpp\">\n.method assembly static void modopt([mscorlib]System.Runtime.CompilerServices.CallConvCdecl) \n        test_pointer_operations(int32 param) cil managed\n{\n  .vtentry 1 : 1\n  // Code size       44 (0x2c)\n  .maxstack  2\n  .locals ([0] int32* ptr,\n           [1] valuetype A* V_1,\n           [2] valuetype A* a,\n           [3] int32 k)\n// k = 0;\n  IL_0000:  ldc.i4.0 \n  IL_0001:  stloc.3\n// ptr = &k;\n  IL_0002:  ldloca.s   k // load local's address instruction\n  IL_0004:  stloc.0\n// *ptr = 1;\n  IL_0005:  ldloc.0\n  IL_0006:  ldc.i4.1\n  IL_0007:  stind.i4 // indirection instruction\n// ptr = &param\n  IL_0008:  ldarga.s   param // load parameter's address instruction\n  IL_000a:  stloc.0\n// *ptr = 2\n  IL_000b:  ldloc.0\n  IL_000c:  ldc.i4.2\n  IL_000d:  stind.i4\n// a = new A;\n  IL_000e:  ldloca.s   a\n  IL_0010:  call       valuetype A* modopt([mscorlib]System.Runtime.CompilerServices.CallConvThiscall) 'A.{ctor}'(valuetype A* modopt([mscorlib]System.Runtime.CompilerServices.IsConst) modopt([mscorlib]System.Runtime.CompilerServices.IsConst))\n  IL_0015:  pop\n// ptra = &a;\n  IL_0016:  ldloca.s   a\n  IL_0018:  stloc.1\n// ptra->meth();\n  IL_0019:  ldloc.1\n  IL_001a:  dup\n  IL_001b:  ldind.i4 // reading the VMT for virtual call\n  IL_001c:  ldind.i4\n  IL_001d:  calli      unmanaged stdcall void modopt([mscorlib]System.Runtime.CompilerServices.CallConvStdcall)(native int)\n  IL_0022:  ret\n} // end of method 'Global Functions'::test_pointer_operations\n</syntaxhighlight>\n\n==See also==\n*[[List of CIL instructions]]\n*[[List_of_CLI_languages]]\n\n==References==\n{{Reflist}}\n\n==External links==\n*[http://www.ecma-international.org/publications/standards/Ecma-335.htm Common Language Infrastructure (Standard ECMA-335)]\n*[https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/ \u201cECMA C# and Common Language Infrastructure Standards\u201d on the Visual Studio website]\n*[[wikibooks:Computer Programming/Hello world#CIL|Hello world program in CIL]]\n*[http://msdn.microsoft.com/en-us/magazine/cc163808.aspx Speed: NGen Revs Up Your Performance With Powerful New Features -- MSDN Magazine, April 2005]\n\n{{Common Language Infrastructure}}\n\n[[Category:Assembly languages]]\n[[Category:Common Language Infrastructure]]\n", "text_old": "{{short description|Intermediate representation defined within the CLI specification}}\n{{confused|C Intermediate Language}}\n{{refimprove|date=November 2017}}\n'''Common Intermediate Language''' ('''CIL'''), formerly called '''Microsoft Intermediate Language''' ('''MSIL''') or '''Intermediate Language''' ('''IL'''),<ref>{{cite web |url = https://docs.microsoft.com/en-us/dotnet/standard/managed-code |title = Intermediate Language & execution}}</ref> is the [[intermediate language]] binary instruction set defined within the [[Common Language Infrastructure]] (CLI) specification.<ref>{{cite web |url = https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf |page = 32 |title = ECMA-335 Common Language Infrastructure (CLI)}}</ref> CIL instructions are executed by a CLI-compatible runtime environment such as the [[Common Language Runtime]]. Languages which target the CLI compile to CIL. CIL is [[object-oriented]], [[Stack machine|stack-based]] [[bytecode]]. Runtimes typically [[Just-in-time compilation|just-in-time]] compile CIL instructions into [[native code]].\n\nCIL was originally known as Microsoft Intermediate Language (MSIL) during the beta releases of the .NET languages. Due to standardization of [[C Sharp (programming language)|C#]] and the CLI, the bytecode is now officially known as CIL.<ref>{{cite web\n| url = http://www.interviewcity.com/2010/04/what-is-intermediate-languageilmsilcil.html\n| title = What is Intermediate Language(IL)/MSIL/CIL in .NET \n| accessdate = 2011-02-17\n| quote = CIL: ... When we compile [a] .NET project, it [is] not directly converted to binary code but to the intermediate language. When a project is run, every language of .NET programming is converted into binary code into CIL. Only some part of CIL that is required at run time is converted into binary code. DLL and EXE of .NET are also in CIL form.}}</ref> [[Windows Defender]] virus definitions continue to refer to binaries compiled with it as MSIL.<ref name=\"Defender\">{{cite web |title=HackTool:MSIL/SkypeCracker |url=https://www.microsoft.com/en-us/wdsi/threats/malware-encyclopedia-description?Name=HackTool:MSIL/SkypeCracker&threatId=-2147221892 |publisher=Microsoft |accessdate=26 November 2019}}</ref>\n\n==General information==\nDuring compilation of [[List of CLI languages|CLI programming languages]], the [[source code]] is translated into CIL code rather than into platform- or processor-specific [[object file|object code]]. CIL is a [[CPU]]- and platform-independent instruction set that can be executed in any environment supporting the Common Language Infrastructure,<ref>\n{{cite book\n| url = https://books.google.com/books?id=VGT1_UJzjM0C&pg=PA15&lpg=PA15&dq=CIL+is+platform-independent#v=onepage&q=CIL%20is%20platform-independent&f=false\n| title = Benefits of CIL\n| accessdate = 2011-02-17\n| quote = Furthermore, given that CIL is platform-agnostic, .NET itself is platform-agnostic...| isbn = 9781590598849\n| last1 = Troelsen\n| first1 = Andrew\n| date = 2009-05-28\n}}\n</ref> such as the [[Common Language Runtime|.NET runtime]] on [[Microsoft Windows|Windows]], or the [[cross-platform]] [[Mono (software)|Mono]] runtime. In theory, this eliminates the need to distribute different executable files for different platforms and CPU types. CIL code is verified for safety during runtime, providing better security and reliability than natively compiled executable files.\n\nThe execution process looks like this:\n\n#Source code is converted to CIL [[bytecode]] and a [[Assembly (CLI)|CLI assembly]] is created.\n#Upon execution of a CIL assembly, its code is passed through the runtime's [[Just-in-time compilation|JIT compiler]] to generate native code. Ahead-of-time compilation may also be used, which eliminates this step, but at the cost of executable-file portability.\n#The computer's processor executes the native code.\n\n==Instructions==\n{{See also|List of CIL instructions}}\n\nCIL bytecode has [[instruction (computer science)|instruction]]s for the following groups of tasks:\n*Load and store\n*[[Arithmetic]]\n*[[Type conversion]]\n*[[Dynamic memory allocation|Object creation and manipulation]]\n*[[stack (data structure)|Operand stack management (push / pop)]]\n*[[branch (computer science)|Control transfer (branching)]]\n*[[Subroutine|Method invocation and return]]\n*[[Exception handling|Throwing exceptions]]\n*[[Monitor (synchronization)|Monitor-based concurrency]]\n*Data and function pointers manipulation needed for C++/CLI and unsafe C# code\n\n==Computational model==\nThe Common Intermediate Language is object-oriented and [[stack-based]]. That means that data is pushed on a stack instead of pulled from registers as in most [[CPU architecture]]s.\n\nIn [[x86]] it might look like this:\n<syntaxhighlight lang=\"asm\">\nadd eax, edx\n</syntaxhighlight>\n\nThe corresponding code in [[Intermediate language|IL]] can be rendered as this, where 0 is eax and 1 is edx:\n<syntaxhighlight lang=\"csharp\">\nldloc.0    // push local variable 0 onto stack\nldloc.1    // push local variable 1 onto stack\nadd        // pop and add the top two stack items then push the result onto the stack\nstloc.0    // pop and store the top stack item to local variable 0\n</syntaxhighlight>\n\nHere are two locals that are pushed on the stack. When the add-instruction is called the operands get popped and the result is pushed. The remaining value is then popped and stored in the first local.\n\n===Object-oriented concepts===\nThis extends to object-oriented concepts as well. You may create objects, call methods and use other types of members such as fields.\n\nCIL is designed to be object-oriented and every [[Method (programming)|method]] needs (with some exceptions) to reside in a class. So does this static method:\n<syntaxhighlight lang=\"csharp\">\n.class public Foo\n{\n    .method public static int32 Add(int32, int32) cil managed\n    {\n        .maxstack 2\n        ldarg.0 // load the first argument;\n        ldarg.1 // load the second argument;\n        add     // add them;\n        ret     // return the result;\n    }\n}\n</syntaxhighlight>\n\nThis method does not require any instance of Foo to be declared because it is static. That means it belongs to the class and it may then be used like this in C#:\n<syntaxhighlight lang=\"csharp\">\nint r = Foo.Add(2, 3);    // 5\n</syntaxhighlight>\n\nIn CIL:\n<syntaxhighlight lang=\"csharp\">\nldc.i4.2\nldc.i4.3\ncall int32 Foo::Add(int32, int32)\nstloc.0\n</syntaxhighlight>\n\n====Instance classes====\n\nAn instance class contains at least one constructor and some instance members. This class has a set of methods representing actions of a Car-object.\n<syntaxhighlight lang=\"csharp\">\n.class public Car\n{\n    .method public specialname rtspecialname instance void .ctor(int32, int32) cil managed\n    {\n        /* Constructor */\n    }\n\n    .method public void Move(int32) cil managed\n    {\n        /* Omitting implementation */\n    }\n\n    .method public void TurnRight() cil managed\n    {\n        /* Omitting implementation */\n    }\n\n    .method public void TurnLeft() cil managed\n    {\n        /* Omitting implementation */\n    }\n\n    .method public void Brake() cil managed\n    {\n        /* Omitting implementation */\n    }\n}\n</syntaxhighlight>\n\n====Creating objects====\n\nIn C# class instances are created like this:\n<syntaxhighlight lang=\"csharp\">\nCar myCar = new Car(1, 4); \nCar yourCar = new Car(1, 3); \n</syntaxhighlight>\n\nAnd these statements are roughly the same as these instructions:\n<syntaxhighlight lang=\"csharp\">\nldc.i4.1\nldc.i4.4\nnewobj instance void Car::.ctor(int, int)\nstloc.0    // myCar = new Car(1, 4);\nldc.i4.1\nldc.i4.3\nnewobj instance void Car::.ctor(int, int)\nstloc.1    // yourCar = new Car(1, 3);\n</syntaxhighlight>\n\n====Invoking instance methods====\n\nInstance methods are invoked like the one that follows:\n<syntaxhighlight lang=\"csharp\">\nmyCar.Move(3);\n</syntaxhighlight>\n\nIn CIL:\n<syntaxhighlight lang=\"csharp\">\nldloc.0    // Load the object \"myCar\" on the stack\nldc.i4.3\ncall instance void Car::Move(int32)\n</syntaxhighlight>\n\n===Metadata===\n{{Main|Metadata (CLI)}}\nCLI records information about compiled classes as [[Metadata]]. Like the type library in the [[Component Object Model]], this enables applications to support and discover the interfaces, classes, types, methods, and fields in the assembly. The process of reading such metadata is called ''[[Reflection (computer science)|reflection]]''.\n\nMetadata can be data in the form of '' attributes''. Attributes can be custom made by extending from the <code>Attribute</code> class. This is a very powerful feature. It allows the creator of the class the ability to adorn it with extra information that consumers of the class can use in various meaningful ways depending on the application domain.\n\n==Example==\nBelow is a basic [[Hello, World]] program written in CIL. It will display the string \"Hello, world!\".\n<syntaxhighlight lang=\"csharp\">\n.assembly Hello {}\n.assembly extern mscorlib {}\n.method static void Main()\n{\n    .entrypoint\n    .maxstack 1\n    ldstr \"Hello, world!\"\n    call void [mscorlib]System.Console::WriteLine(string)\n    ret\n}\n</syntaxhighlight>\n\nThe following code is more complex in number of opcodes.\n\n''This code can also be compared with the corresponding code in the article about [[Java bytecode]].''\n<syntaxhighlight lang=\"csharp\">\nstatic void Main(string[] args)\n{\n    for (int i = 2; i < 1000; i++)\n    {\n        for (int j = 2; j < i; j++)\n        {\n             if (i % j == 0)\n                 goto outer;\n        }\n        Console.WriteLine(i);\n        outer:;\n    }\n}\n</syntaxhighlight>\n\nIn CIL syntax it looks like this:\n<syntaxhighlight lang=\"cpp\">\n.method private hidebysig static void Main(string[] args) cil managed\n{\n    .entrypoint\n    .maxstack  2\n    .locals init (int32 V_0,\n                  int32 V_1)\n\n              ldc.i4.2\n              stloc.0\n              br.s       IL_001f\n    IL_0004:  ldc.i4.2\n              stloc.1\n              br.s       IL_0011\n    IL_0008:  ldloc.0\n              ldloc.1\n              rem\n              brfalse.s  IL_001b\n              ldloc.1\n              ldc.i4.1\n              add\n              stloc.1\n    IL_0011:  ldloc.1\n              ldloc.0\n              blt.s      IL_0008\n              ldloc.0\n              call       void [mscorlib]System.Console::WriteLine(int32)\n    IL_001b:  ldloc.0\n              ldc.i4.1\n              add\n              stloc.0\n    IL_001f:  ldloc.0\n              ldc.i4     0x3e8\n              blt.s      IL_0004\n              ret\n}\n</syntaxhighlight>\n\nThis is just a representation of how CIL looks like near VM-level. When compiled the methods are stored in tables and the instructions are stored as bytes inside the assembly, which is a [[Portable Executable]] (PE).\n\n==Generation==\nA CIL assembly and instructions are generated by either a compiler or a utility called the ''IL Assembler'' ([[ILAsm]]) that is shipped with the execution environment.\n\nAssembled CIL can also be disassembled into code again using the ''IL Disassembler'' (ILDASM). There are other tools such as [[.NET Reflector]] that can decompile CIL into a high-level language (e.&nbsp;g. C# or [[Visual Basic .NET|Visual Basic]]). This makes CIL a very easy target for reverse engineering. This trait is shared with [[Java bytecode]]. However, there are tools that can [[Obfuscated code|obfuscate]] the code, and do it so that the code cannot be easily readable but still be runnable.\n\n==Execution==\n\n===Just-in-time compilation===\n[[Just-in-time compilation]] (JIT) involves turning the byte-code into code immediately executable by the CPU. The conversion is performed gradually during the program's execution. JIT compilation provides environment-specific optimization, runtime type safety, and assembly verification. To accomplish this, the JIT compiler examines the assembly metadata for any illegal accesses and handles violations appropriately.\n\n===Ahead-of-time compilation===\n[[Common Language Infrastructure|CLI]]-compatible execution environments also come with the option to do an [[Ahead-of-time compilation]] (AOT) of an assembly to make it execute faster by removing the JIT process at runtime.\n\nIn the [[.NET Framework]] there is a special tool called the [[Native Image Generator]] (NGEN) that performs the AOT. A different approach for AOT is [[CoreRT]] that allows the compilation of .Net Core code to a single executable with no dependency on a runtime. In [[Mono (programming)|Mono]] there is also an option to do an AOT.\n\n==Pointer instructions - C++/CLI==\nA notable difference from Java's bytecode is that CIL comes with ldind, stind, ldloca, and many call instructions which are enough for data/function pointers manipulation needed to compile C/C++ code into CIL.\n\n<syntaxhighlight lang=\"cpp\">\nclass A {\n   public: virtual void __stdcall meth() {}\n};\nvoid test_pointer_operations(int param) {\n\tint k = 0;\n\tint * ptr = &k;\n\t*ptr = 1;\n\tptr = &param;\n\t*ptr = 2;\n\tA a;\n\tA * ptra = &a;\n\tptra->meth();\n}\n</syntaxhighlight>\n\nThe corresponding code in CIL can be rendered as this:\n\n<syntaxhighlight lang=\"cpp\">\n.method assembly static void modopt([mscorlib]System.Runtime.CompilerServices.CallConvCdecl) \n        test_pointer_operations(int32 param) cil managed\n{\n  .vtentry 1 : 1\n  // Code size       44 (0x2c)\n  .maxstack  2\n  .locals ([0] int32* ptr,\n           [1] valuetype A* V_1,\n           [2] valuetype A* a,\n           [3] int32 k)\n// k = 0;\n  IL_0000:  ldc.i4.0 \n  IL_0001:  stloc.3\n// ptr = &k;\n  IL_0002:  ldloca.s   k // load local's address instruction\n  IL_0004:  stloc.0\n// *ptr = 1;\n  IL_0005:  ldloc.0\n  IL_0006:  ldc.i4.1\n  IL_0007:  stind.i4 // indirection instruction\n// ptr = &param\n  IL_0008:  ldarga.s   param // load parameter's address instruction\n  IL_000a:  stloc.0\n// *ptr = 2\n  IL_000b:  ldloc.0\n  IL_000c:  ldc.i4.2\n  IL_000d:  stind.i4\n// a = new A;\n  IL_000e:  ldloca.s   a\n  IL_0010:  call       valuetype A* modopt([mscorlib]System.Runtime.CompilerServices.CallConvThiscall) 'A.{ctor}'(valuetype A* modopt([mscorlib]System.Runtime.CompilerServices.IsConst) modopt([mscorlib]System.Runtime.CompilerServices.IsConst))\n  IL_0015:  pop\n// ptra = &a;\n  IL_0016:  ldloca.s   a\n  IL_0018:  stloc.1\n// ptra->meth();\n  IL_0019:  ldloc.1\n  IL_001a:  dup\n  IL_001b:  ldind.i4 // reading the VMT for virtual call\n  IL_001c:  ldind.i4\n  IL_001d:  calli      unmanaged stdcall void modopt([mscorlib]System.Runtime.CompilerServices.CallConvStdcall)(native int)\n  IL_0022:  ret\n} // end of method 'Global Functions'::test_pointer_operations\n</syntaxhighlight>\n\n==See also==\n*[[List of CIL instructions]]\n\n==References==\n{{Reflist}}\n\n==External links==\n*[http://www.ecma-international.org/publications/standards/Ecma-335.htm Common Language Infrastructure (Standard ECMA-335)]\n*[https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/ \u201cECMA C# and Common Language Infrastructure Standards\u201d on the Visual Studio website]\n*[[wikibooks:Computer Programming/Hello world#CIL|Hello world program in CIL]]\n*[http://msdn.microsoft.com/en-us/magazine/cc163808.aspx Speed: NGen Revs Up Your Performance With Powerful New Features -- MSDN Magazine, April 2005]\n\n{{Common Language Infrastructure}}\n\n[[Category:Assembly languages]]\n[[Category:Common Language Infrastructure]]\n", "name_user": "Rickylqhan", "label": "safe", "comment": "Add link to Common Language Infrastructure languages", "url_page": "//en.wikipedia.org/wiki/Common_Intermediate_Language"}
