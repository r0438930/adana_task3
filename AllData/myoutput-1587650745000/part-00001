{"title_page": "FOCAL (programming language)", "text_new": "{{short description|Programming language used on DEC PDP-series machines}}\n{{For|the unrelated programming language on HP calculators|FOCAL (Hewlett-Packard)}}\n{{Infobox programming language\n| name = FOCAL\n| paradigm = \n| released = {{Start date and age|1968}}\n| developer = Richard Merrill, [[Digital Equipment Corporation|DEC]]\n| influenced by = [[JOSS]]\n| influenced = [[BASIC-PLUS]]\n| website = \n}}\n'''FOCAL''' is an interactive [[interpreter (computing)|interpreted]] [[programming language]] based on [[JOSS]] and primarily used on [[Digital Equipment Corporation]] (DEC) [[Programmed Data Processor|PDP-series]] machines. The name is an acronym for '''F'''ormulating '''O'''n-Line '''C'''alculations in '''A'''lgebraic '''L'''anguage.{{sfn|Manual|1968|p=1.1}}\n\nFOCAL is very similar to JOSS in terms of the commands it supports and the general syntax of the language. It differs in that many of JOSS' advanced features like [[Range (computer programming)|ranges]] and [[user-defined function]]s were removed to simplify the parser. Some of the keywords were renamed so that they all start with a unique first letter. This allows users to type in programs using single-character statements, further reducing memory needs. This was an important consideration on the [[PDP-8]], which was often limited to a few [[kilobyte]]s (KB).\n\nLike JOSS, and later BASICs, FOCAL on the PDP-8 was a complete environment that included a line editor, the interpreter, and input/output routines. The package as a whole was called '''FOCAL-8''', which also ran on the [[PDP-5]] and [[PDP-12]]. When ported to the [[PDP-11]], the resulting '''FOCAL-11''' relied on the underlying [[operating system]], [[RT-11]], to provide file support and editing. The language definition was updated twice, to '''FOCAL-69''' and a very slightly modified '''FOCAL-71'''. A port to the [[Intel 8080]] was also available.\n\nFOCAL is historically notable as the language for the original versions of the early [[video game]]s [[Hamurabi (video game)|''Hamurabi'']] and [[Lunar Lander (video game genre)|''Lunar Lander'']]. Both were later ported to BASIC where they became much more famous.<ref name=\"TIME\">{{cite web |url=http://time.com/69316/basic/ |title=Fifty Years of BASIC, the Programming Language That Made Computers Personal |work=[[Time (magazine)|Time]] |last=McCracken |first=Harry |date=2014-04-29 |access-date=2016-02-12 |archive-url=https://web.archive.org/web/20160205214236/http://time.com/69316/basic/ |archive-date=2016-02-05 |url-status=live}}</ref> FOCAL was not popular outside the PDP platform and largely disappeared during the move to the [[VAX-11]]. It had a strong revival in the [[Soviet Union]] where PDP-11 clones were used as educational and [[home computer]]s.\n\n==History==\n=== JOSS ===\n[[JOSS]] was released in May 1963 on the one-off [[JOHNNIAC]] computer at [[RAND Corporation]]. Within RAND, use grew rapidly, and the machine, originally constructed in 1953, quickly ran out of capability. JOHNNIAC retired in 1966 and JOSS moved to a newly purchased [[PDP-6]], [[Digital Equipment Corporation]]'s (DEC) first \"big\" machine. Usage continued to grow and by 1970 the system was being used by 500 to 600 users across the country and had spawned a number of innovations such as mobile [[computer terminal]]s that could be wheeled from room to room and plugged in for instant access.<ref name=rand>{{cite techreport |url=https://www.rand.org/content/dam/rand/pubs/reports/2008/R918.pdf |title=The JOSS Years: Reflections on an experiment |first=Shirley |last=Marks |date=December 1971 |publisher=Rand}}</ref>\n\nJOSS was extremely influential in the computer field. It emerged just as the [[time-sharing]] concept was being introduced and there was significant interest in man-machine interaction and computers were seeing more widespread use. Whereas most timeshare [[operating system]]s of the era concentrated on user account and file management, leaving the users on their own when it came to programming, JOSS provided these functions and an easily used programming language in a single package. RAND showed the system to a parade of people in the industry.<ref name=rand/>\n\n===FOCAL===\nPorts of JOSS to other platforms began to appear shortly after the PDP-6 version was released. FOCAL was one example of its many offshoots.\n\nWritten by [[Richard Merrill]], FOCAL removed features as required in order to be able to run in the much more limited memory space of the [[PDP-8]] and other 12-bit machines in the DEC lineup. To achieve this, a major change was made to reduce the amount of temporary data, or \"[[State (computer science)|state]]\", needed to parse the statements. One noticeable effect of this decision was that [[Conditional (computer programming)|conditionals]] could only be used for [[Branch (computer science)|branches]], in contrast to JOSS, where conditionals can be applied to any statement.\n\nThe other noticeable change was to rearrange the keywords so each started with a unique letter. This simplified the [[Parsing|parser]], which needed to read only the first letter of the command on a line of code, and could then skip forward to the next blank. In contrast, JOSS had to continue reading until it had read the entire command word, and then compare that against a list containing complete words. Users could save memory by typing in only that letter, reducing the size of the [[source code]].\n\nThe first version of FOCAL was released in 1968 for the [[PDP-8]]. An updated version followed the next year, which was later known as FOCAL-69. The system as a whole, regardless of version, was known as FOCAL-8 when it was ported to other machines in the 12-bit series, including the [[PDP-5]] and [[PDP-12]]. It was popular as it was highly efficient in terms of memory use, which was often severely limited on these machines to a few [[kilobyte]]s (KB). The similar FOCAL-11 ran on the [[PDP-11]] under [[RT-11]].\n\n[[Processor Technology]] also offered a version of 8k FOCAL, complete with Lunar Lander, for the [[Intel 8080]]-based [[Altair 8800]] system. This was provided for the copying charge of the tape, while the [[source code]] was provided for free with other purchases.<ref>{{cite magazine |url=https://archive.org/details/byte-magazine-1976-04/page/n49 |title=Watch Your Altair Grow! |magazine=Byte |date=April 1976 |page=48}}</ref>\n\n===BASIC===\nWhile FOCAL was becoming popular on DEC machines, BASIC was becoming a more popular alternative on other platforms. By the late 1960s, a number of companies were making inroads in DEC's minicomputer stronghold selling similar machines running timeshared versions of BASIC. Notable among these was the [[HP 2100]] series, running [[HP Time-Shared BASIC]].{{sfn|Szczepaniak|2014}}\n\n[[David H. Ahl]] had recently joined DEC's PDP-8 Group, just as the company became interested in selling the machine into educational settings. Due to the popularity of BASIC in the educational market, especially with the growing library of BASIC programs from the [[Minnesota Educational Computing Consortium]], Ahl found selling the machine with FOCAL was difficult in spite of its advantages.{{sfn|Szczepaniak|2014}} As he later noted:\n\n{{Quote | style=font-size:100% | |DEC's FOCAL language was equal to BASIC in most aspects and even better in some, but it had one huge drawback: DEC was unwilling to license it to other computer manufacturers. FOCAL was fighting an uphill battle against BASIC, which was available on GE, Honeywell, HP, and other computers.<br /><br />I think it wound up with a situation like Sony and Betamax. Sony saying, \"Betamax is ours and it is a better format than VHS,\" which it was. But then, JVC saying, \"We have VHS and Toshiba. Hey, do you want to use it? Fine, we'll license it to you for next to nothing.\"{{sfn|Szczepaniak|2014}}}}\n\nAhl took it upon himself to produce a BASIC system for the platform, hiring a company he later learned was a single programmer in Brooklyn to produce a version for the 4&nbsp;kWord PDP-8. DEC began selling packaged versions of the PDP-8 with terminals and the BASIC as the \"EduSystem\" lineup, with larger systems in the series having expanded versions of BASIC, and in some cases, FOCAL and [[FORTRAN]] as well. Some PDP-11 based EduSystems were also created.<ref name=edu>{{cite book |url=http://bitsavers.trailing-edge.com/pdf/dec/pdp8/tss8/EduSystemHandbookJan73.pdf |title=EduSystem Handbook |page=V |publisher=Digital |date=1973}}</ref>\n\nAhl then began porting programs from FOCAL to BASIC, notably [[Hamurabi (video game)|''The Sumer Game'']] (which he renamed ''Hamurabi''), a version of [[Lunar Lander (video game genre)|''Lunar Lander'']], and a number of smaller FOCAL demos. Combining his ports with submissions from outside programmers, he managed to collect enough material to have DEC publish ''101 BASIC Computer Games'' in 1973. The book was an immediate success and ultimately ran through three printings to 1975.{{sfn|Savetz|2013}}{{sfn|Szczepaniak|2014}}\n\nBy the mid-1970s BASIC was a standard feature of all DEC machines and FOCAL use evaporated.{{sfn|Savetz|2013}}\n\n===Rebirth in the Soviet Union===\nThe PDP-11 had been cloned in the [[Soviet Union]] in the 1970s for military purposes. In the 1980s, single-chip variations similar to the [[LSI-11]] were produced that gave rise to a series of PDP-11 compatible [[home computer]]s. Most notable among several models were the [[Electronika BK]] series, released in 1985. These were initially supplied with FOCAL on a [[ROM cartridge]],<ref>{{cite techreport|url=https://www.ucis.pitt.edu/nceeer/1988-802-8-Stapleton.pdf |title=The Soviet Union and the Personal Computer \"Revolution\" |page=8 |first1=R.A. |last1=Stapleton |first2=S.E. |last2=Goodman |date=June 1988 |publisher=University of Arizona}}</ref> while a BASIC cartridge was an optional add-on. Later models supplied BASIC by default.<ref>{{cite web |url=https://oldcomputermuseum.com/elektronika_bk0010.html |title=Elektronika BK-0010 |website=Old Computer Museum}}</ref>\n\n==Language==\nThe following description is based on FOCAL-69 as seen in the FOCAL-8 language reference manual.{{sfn|Manual|1968}}\n\n===Direct and indirect modes===\nFOCAL followed the JOSS model for interaction via a [[command line interface]]. This allowed users to type in commands in \"direct mode\", which were performed immediately, or to prefix them with a line number, in which case they were added to the program if they were unique, or overrode existing code if the same number had previously been used.{{sfn|Manual|1968|p=2.1}}\n\nThe method of operation is similar to BASIC's \"immediate mode\" vs. \"program mode\". It contrasts with JOSS, in which all commands, both program and direct, were saved and loaded as part of the user's workspace. This allowed JOSS to have commands without line numbers, which they used for {{code|Form}} definitions and other tasks. FOCAL lacked this capability, so those instructions that needed to be loaded and saved became options on other program-mode commands like {{code|Type}}.{{sfn|Manual|1968|p=2.1}}\n\n===Program statements===\nEvery line in a FOCAL program must start with a line number. As with JOSS, line numbers are fixed-point numbers consisting of two two-digit integers separated by a period. In FOCAL-8, valid line numbers range from 1.01 through 31.99. When printed out, using {{code|WRITE}}, the FOCAL equivalent to BASIC's {{code|LIST}}, leading zeros will be added so that all line numbers. This means all line numbers will be a total of five characters including the period; 1.10 will be printed as {{code|01.10}}. Statements referring to those lines do not need the leading zeros, for instance, {{code|GOTO 1.10}}.{{sfn|Manual|1968|p=2.7}}\n\nThe number on the left of the period is known as the \"group number\". Groups provide some level of code organization that is lacking in languages like Fortran or BASIC. The primary use of these was to use a group as a [[subroutine]] which can be called with {{code|DO}}, for instance, {{code|DO 5}} which will jump to the subroutine written in group 5. The editor also used these during edit-time, for instance, one could {{code|WRITE 2}} to produce a listing of the code in group 2, or {{code|ERASE 4}} to delete all of the lines in group 4.{{sfn|Manual|1968|p=2.7}}\n\nEvery line must start with a command keyword following the line number.{{sfn|Manual|1968|p=2.7}} There is no concept of a \"default command\" as is the case in BASIC with its optional {{code|LET}} statement. Multiple statements can be placed on a single line, separated by semicolons. Usually, the behavior is no different than if the statements had been on separate lines, except in the case of FOR loops.{{sfn|Manual|1968|p=3.7}}\n\n=== Commands ===\n====ASK====\nThe {{code|ASK}} command (abbreviation A) will take a list of strings and variables, echo the strings and store the user input in variables.{{sfn|Manual|1968|p=3.2}} Equivalent to BASIC's {{code|INPUT}}.\n\n 01.01 ASK \"NAME\", NAME\n 01.02 ASK \"COORDINATES\", X, Y\n 01.03 ASK \"A1\",A1,\"OMEGA\",W,\"T0\",T0,\"DAMPING FACTOR\",DAMPINGFACTOR\n\nIf the user doesn't enter a number but enters text, the system will convert the initial character to a number with \"A\"=1, \"B\"=2, etc.\n\n====COMMENT====\nThe {{code|COMMENT}} command (abbreviation C) creates a remark.{{sfn|Manual|1968|p=3.6}} Equivalent to BASIC's {{code|REM}}.\n 01.01 COMMENT: THE SUMER GAME, BY RICHARD MERRILL\n\n====DO====\nThe {{code|DO}} command (abbreviation D) branches execution to a subroutine. It is the equivalent of BASIC's {{code|GOSUB}}. The subroutine is referenced either by group number or line number. If a line number is provided, that single line is run and then returns to the statement after the {{code|DO}}. If no line number is provided, execution starts at the first line of the block and continues until the end of the block is reached or a {{code|RETURN}} is encountered. {{code|RETURN}} is only required to return early from the group, it is not needed at the end of the group.{{sfn|Manual|1968|p=3.4}}\n 01.15 DO 7.24\n 01.16 DO 8\n\n====FOR====\nThe {{code|FOR}} command (abbreviation F) implements a [[for loop]]. When three arguments are specified, the first is the initial value of the loop variable, the second is the increment, and the third value is the terminating value for the loop. If two values are provided, the first is the initial value and the second is the terminating value, and the increment is set to 1.\n\nIn contrast to other parts of the language where multiple statements on a line are independent, the {{code|FOR}} always runs the statements that follow it on the line before the termination has been met, and then continues to the next line. Thus, loops have to be on a single line, or alternately, call a subroutine with {{code|DO}}. There is no equivalent of BASIC's {{code|NEXT}}.{{sfn|Manual|1968|p=3.7}}\n 01.01 FOR X=1,10; TYPE X,!\n 01.02 FOR X=0,10,100; DO 2\n\nA sample FOR loop:\n 01.10 ASK \"HOW MUCH MONEY DO YOU WANT TO BORROW ?\",PRINCIPAL\n 01.20 ASK \"FOR HOW MANY YEARS ?\",TERM\n 01.30 FOR RATE=4.0,.5,10;DO 2.0\n 01.40 QUIT\n 02.10 SET INTEREST=PRINCIPAL*(RATE/100)*TERM\n 02.20 TYPE \"RATE\",RATE,\"   \",\"INTEREST\",INTEREST,!\n\n====GOTO====\nThe {{code|GOTO}} command (abbreviation G) jumps program execution to the specified line number.{{sfn|Manual|1968|p=3.4}} It is identical to the same-named statement in BASIC. In FOCAL, {{code|GOTO}} is also used to begin execution, like BASIC's {{code|RUN}}, but in this usage, the documentation refers to it as {{code|GO}} instead of {{code|GOTO}} in spite of the underlying command being the same.\n 01.05 GOTO 1.01\n 02.90 TYPE !!,\"TRY AGAIN.\",!!!!!;GOTO 1.1\n\n====IF====\nThe {{code|IF}} command (abbreviation I) provides a conditional branch based on the sign of the expression. After the numeric expression, the IF command can take one to three line numbers. If the expression is less than zero, execution branches to the first line number;  if equal to zero, to the second line number;  if greater than zero, to the third line number. The language lacked relative operators such as greater than, equal or less than. To branch if X > 5, one must compare X - 5.{{sfn|Manual|1968|p=3.5}}\n 02.20 IF (25-25) 2.4,2.3,2.4\n 03.01 IF (X) 3.1,3.02,3.1\n\nIF could be short-formed by placing a semicolon (or end of line) beyond the first line number. For instance:\n\n 02.20 IF (X)1.8; TYPE \"Q\"\n 02.30 IF (X)1.8,2.50\n 02.40 TYPE \"P\"\n\nIn this case the test at 2.20 will cause the program to jump to line 1.8 if the test is negative, otherwise it will continue and type \"Q\" to the console. Line 2.30 will jump to 1.8 or 2.5 if the value is negative or zero, and otherwise continue to type \"P\" to the console.{{sfn|Manual|1968|p=3.5}}\n\n====QUIT====\nThe {{code|QUIT}} command (abbreviation Q) terminates execution of the program and returns control to the editing environment.{{sfn|Manual|1968|p=3.6}} Equivalent to BASIC's {{code|STOP}} or {{code|END}}.\n 01.10 FOR X=-10,1,10;TYPE X\n 01.20 QUIT\n\n====RETURN====\nThe {{code|RETURN}} command (abbreviation R) branches execution from a subroutine back to the calling location.{{sfn|Manual|1968|p=3.6}} The use of {{code|RETURN}} is optional at the last line of a subroutine, a subroutine returns at the last line in the group anyway. The following is a sample subroutine for converting a yes/no prompt into a value.[http://www.pdp8.net/lang/focal/misc.shtml]\n 22.78 COMMENT: 'YES OR NO' SUBROUTINE\n 22.80 ASK \"ANSWER YES OR NO ?  \",AN\n 22.82 IF (AN-0YES)22.84,22.86\n 22.84 IF (AN-0NO)22.8,22.88,22.8\n 22.86 SET X=2;RETURN\n 22.88 SET X=1;RETURN\n\n====SET====\nThe {{code|SET}} command (abbreviation S) assigns the results of an expression to the specified variable.{{sfn|Manual|1968|p=3.3}} Equivalent to BASIC's {{code|LET}}.\n 01.30 SET PI=3.14156\n 01.60 SET INTEREST=PRINCIPAL*(RATE/100)*TERM\n\n====TYPE ====\nThe {{code|TYPE}} command (abbreviation T) provides for output of one or more items separated by commas.{{sfn|Manual|1968|p=3.1}} Equivalent to BASIC's {{code|PRINT}}.\n\nItems can be variables, literal strings surrounded by double-quotes, or a variety of control characters. The control characters include the {{code|!}} to output a carriage return and line feed, {{code|#}} for the carriage return alone, and {{code|:}} for a tab character. Control characters can be strung together, for instance, {{code|!!!}} will output three CR/LFs without the need to separate them with commas.{{sfn|Manual|1968|p=3.2}}\n\n TYPE [NUMBERS, E1, \"TEXT\", !, #, :, $ OR %] ...OUTPUT\n 01.10 TYPE \"HI THERE, GOOD LOOKING.  HOW MUCH MONEY DO YOU WANT TO BORROW?\",!\n 01.50 TYPE \"INTEREST\",INTEREST,!\n 01.80 TYPE \"THE INTEREST FOR\",TERM,\" YEARS\",!,\"IS\",INTEREST, \" DOLLARS.\",!!\n 01.90 TYPE \"NEW YORK\",!,\"WASHINGTON\",!,\"ATLANTA\",!,\"DALLAS\",!\n 02.10 TYPE \"X\",X,\"   \",\"X^2\",X^2,\"   \",\"SQRT\",FSQT(X)\n 03.20 TYPE \".\",#\n 02.20 TYPE !!!!!\n\n{{code|TYPE}} also included an optional format specifier indicated using the format {{code|%x.yz}}, where x is the number of digits to the left of the decimal, and yz is the number of digits to the right of the period. The default format was {{code|%8.4}}, meaning a maximum of eight digits and four to the right of the period.{{sfn|Manual|1968|p=2.2}} So, for instance:\n\n SET A=67823\n TYPE %6.01,A\n =  67823.0\n TYPE %5,A\n = 67823\n TYPE %8.03,A\n =   67823.000\n TYPE %,A\n = 6.7823E4\n\nNote the extra leading spaces in some examples, padding out the full defined width. Using % alone caused the output to be printed in \"floating point format\" using the E.{{sfn|Manual|1968|p=2.3}}\n\nA special control character was {{code|$}} which caused a table of all defined variables and their values to be printed. Only the first two letters of the name will be printed, padded with a zero if need be. Arrays elements are printed on separate lines and variables with only one element will be indexed (00). For example:{{sfn|Manual|1968|p=2.5}}\n\n TYPE $\n A0(00)=67823\n\n=== Variables ===\nVariable names may start with any letter except F (F is reserved for functions) and may contain any sequence of letters and numbers. However, only the first two characters are significant. For instance, the following code sample from ''FOCAL: A New Conversational Language''<ref>{{cite book |title=FOCAL: A New Conversational Language |url=http://www.cs.uiowa.edu/~jones/pdp8/focal/focal69.html |publisher=Digital}}</ref> refers to the same variable as DESTINATION and then DES. Internally, both references refer to a variable designated DE:\n 01.80 ASK DESTINATION\n 02.30 IF (DES-14) 2.4,3.1,2.4\n\nAny variable may be treated as an array, allowing subscripts from -2048 through 2047.[http://www.pdp8.net/lang/focal/misc.shtml]\n\n=== Math ===\nFOCAL-69 contained only five mathematical operators:{{sfn|Manual|1968|p=2.4}}\n* {{code|^}} for exponents - the exponent is converted to a 12-bit integer\n* {{code|*}} for multiplication\n* {{code|/}} for division\n* {{code|+}} for addition\n* {{code|-}} for subtraction\n\nOne curiosity of FOCAL was that the operators all had independent precedence, as in the order above. That means that the formula {{code|SET T{{=}}2-3+1}}, it would be evaluated in the order 2-(3+1) and thus produce -2. This was very different than most languages, where the + and - had equal precedence and would be evaluated (2-3)+1 to produce 0.{{sfn|Manual|1968|p=2.4}} This can cause subtle errors when converting FOCAL source code to other systems.\n\nFOCAL was unusual in that mathematical expressions could use (), [] and <> interchangeably in matched pairs to establish precedence.{{sfn|Manual|1968|p=2.4}} For instance, the following is a valid expression:\n\n   01.30 SET A=<10*[5+1]*(1+5)>\n\nAll of these are the same level of precedence and read left-to-right when at the same level, so this statement will be evaluated [], then (), then <>, to produce 360.{{sfn|Manual|1968|p=2.4}}\n\nThe language contained the following built-in functions:{{sfn|Manual|1968|p=3.10}}\n* {{code|FABS()}} - Absolute value\n* {{code|FATN()}} - Arctangent\n* {{code|FCOS()}} - Cosine of argument in radians\n* {{code|FEXP()}} - Natural base to the power of the argument\n* {{code|FITR()}} - Integer part of the argument\n* {{code|FLOG()}} - Naperian log\n* {{code|FRAN()}} - Random number\n* {{code|FSGN()}} - Sign of the argument; FSGN(0)=1 in FOCAL-69, but FSGN(0)=0 in FOCAL-71 as well as later versions\n* {{code|FSIN()}} - Sine of an angle given in radians\n* {{code|FSQT()}} - Square root\n\n===Other functions===\nFOCAL also included a number of special-purpose functions:{{sfn|Manual|1968|p=A.3}}\n\n* {{code|FDIS}} took two values and plotted a dot on the screen of graphical terminals\n* {{code|FADC}} read a value from a numbered analog input and returned an integer value\n\n==Environment commands==\n====Running programs====\nFOCAL used {{code|GOTO}} in the editor to start a program. However, a rule-of-thumb was to shorten this to {{code|GO}}. This is the equivalent of {{code|RUN}} in BASIC. {{code|GOTO}} can also be used in the editor to start execution at a specified line.\n\n====Editing commands====\nNew lines are entered into the program by simply beginning the command with a line number.  The editing commands were ERASE (abbreviation E),{{sfn|Manual|1968|p=2.4}} MODIFY (abbreviation M){{sfn|Manual|1968|p=3.8}} and WRITE (abbreviation W):{{sfn|Manual|1968|p=3.2}}\n* <code>ERASE</code> - zeroes out all variables. this is sometimes found within programs to reset them\n* <code>ERASE ''line number''</code> - deletes the statement at the specified line\n* <code>ERASE ''group number''</code> - deletes all statements in the specified group\n* <code>ERASE ALL</code> - deletes the entire program\n* <code>MODIFY ''line number''</code> - allows the programmer to edit the specified line\n* <code>WRITE ''line number''</code> - display the statement at the specified line\n* <code>WRITE ''group number''</code> - display all statements in the specified group\n* <code>WRITE ALL</code> - display the specified program\n\n====File commands====\nThe file command was OPEN (abbreviation O):\n* {{code|OPEN INPUT [device:][file][,ECHO]}} - prepare to read from the start of a file\n* {{code|OPEN OUTPUT [device:][file][,ECHO]}} - prepare to write from the start of a file\n* {{code|OPEN RESTORE INPUT[,ECHO]}} - resume input\n* {{code|OPEN RESTORE OUTPUT[,ECHO]}} - resume output\n* {{code|OUTPUT CLOSE}} - output the buffer and close the file\n\n====Library commands====\nFOCAL included the ability to manage collections of FOCAL programs as a code library. Programs could call other programs in a chain fashion using {{code|LIBRARY CALL}}, or call a single subroutine in another program using {{code|LIBRARY GOSUB}}. Program names could be six characters long. The LIBRARY command (abbreviation L) had the following sub-commands:\n\n* <code>LIBRARY DELETE [device:]''program name></code> - delete a program\n* <code>LIBRARY LIST [device:][file name]</code> - catalog\n* <code>LIBRARY RUN [device:]''program name'' [line number]</code> - chain the program, optionally resuming at the specified line number\n* <code>LIBRARY SAVE [device:]''program name''</code> - save the program\n* <code>LIBRARY EXIT</code> - return to the PDP-8 monitor program\nFOCAL-71 added:\n* <code>LIBRARY CALL [device:]''program name''</code> - load a program\n* <code>LIBRARY GOSUB [device:]''program name'' [group number]</code> - call a subroutine in an external program\n\n==Error codes==\nSince the interpreter lacked sufficient memory space to store error messages, or even a table of error numbers, FOCAL used a workaround by reporting the address of the error-detecting code as a fixed-point number. For example, the [[division by zero]] error was detected it would report {{code|?28.73 @ 01.10}}, where 28.73 represents the code checking for this error at memory page 28 plus an offset of 73 words, and 01.10 is the line number where the error occurred. Pages in the PDP-8 were 128 bytes long, so this address translates to location 3657.\n\n==Changes between versions==\nDEC released three versions of FOCAL for the PDP-8 series, the original, known simply as FOCAL, and two updated versions, \nFOCAL,1969 and FOCAL,1971. FOCAL,1969 was largely identical to the original, but FOCAL,1971 was major update that added file handling, new mathematics, and a variety of other changes. In contrast to the first two versions, which were stand-alone systems, FOCAL,1971 was based on the emerging [[OS/8]] (then still known as PS/8) and relied more heavily on that operating system for file handling and editing.\n\n===FOCAL,1971===\nOne change in the new version was a 10-digit math package for added precision. The {{code|FSGN}} function now returned zero if the input expression evaluated to zero. Previously this would return one. The {{code|FRAN}} now used a better algorithm that produced more randomly distributed numbers. It also added the new {{code|FIN}} function that took a string and returned its [[ASCII]] value (akin to BASIC's {{code|ASC}}) and {{code|FOUT}} which took a number and returned a string with that ASCII character ({{code|CHR}}.\n\nAs all of these options used up limited memory, when started, FOCAL,1971 entered a dialog that asked the user what features they wanted to use.\n\n==Comparison with JOSS==\nFOCUL is, for all intents, a cleaned-up version of JOSS with changes to make the syntax terser and easier to parse. Almost all FOCAL commands have a one-to-one correspondence with JOSS and differ only in details. A few features of JOSS were missing in FOCAL.\n\nOne major difference is that JOSS included a complete set of comparison operations and a [[boolean logic]] system that operated within if and for constructs. Furthermore, the ifs and loops could be applied to any statement, in contrast to FOCAL, where the only operation either could carry out was the equivalent to a goto. For instance, in JOSS, one could:\n\n  1.10 Type A if X>10.\n  1.20 Type i for i=1(1)10.\n\nWhich would optionally print A based on the test, and then print the numbers 1 to 10. In contrast, FOCAL lacked the ability to compare values, and loops were applied by skipping to the next line when they completed. The equivalent code in FOCAL would be:\n\n 1.10 IF (X-10) ,,1.30\n 1.20 TYPE A!\n 1.30 FOR I=1,1,10;TYPE I,!\n\nJOSS' implementation makes common constructs easier to build and more closely match the programmer's intentions, at the cost of making the runtime more complex. For instance, JOSS allowed ranges in loops to be described in a flexible fashion, for instance, 1,2,3,10(5)50,75,78. This flexibility comes at a cost; in FOCAL the start, stop and step can be written down in a custom in-memory structure and easily updated as the loop is performed. In contrast, the JOSS system requires a pointer to what might be, but often isn't, a more complex expression that has to be stepped over with more complex parsing code.\n\nIn terms of making the code terser, changes were relatively minor. For instance, JOSS' {{code|Do part 20.}} becomes the slightly smaller FOCAL {{code|DO 20}}, while {{code|Do step 20.1}} becomes {{code|DO 20.1}}. Command keywords were also shortened where possible, so JOSS' {{code|Demand}} becomes FOCAL's {{code|ASK}}, both to make it shorter as well as allow the letter D to be uniquely used for {{code|DO}}. The period needed to indicate the end of a line in JOSS was removed.\n\nTo simplify the parser, some FOCAL options were removed. For instance, JOSS could perform multiple assignments with {{code|Set S{{=}}P, P{{=}}Q, Q{{=}}S.}} while in FOCAL these had to be made individual statements, {{code|SET S{{=}}P; SET P{{=}}Q; SET Q{{=}}S}}. Likewise, JOSS' {{code|Form}}, used to format output, was combined into FOCAL's {{code|TYPE}} with the {{code|%}}.\n\n==Comparison with BASIC==\nComparisons between FOCAL and BASIC were inevitable since both languages were common on [[minicomputer]]s of the same era, and the two languages have much in common in terms of syntax and structure. In most cases, there is a direct conversion of FOCAL code to and from BASIC. For instance, to ask the user to input a value, in FOCAL one would:\n\n  ASK \"What is your age?\",AGE\n\nwhile in BASIC the equivalent is:\n\n  INPUT \"What is your age?\",AGE\n\nWith the exception of a few features that were missing from one or the other, and some relatively minor differences in syntax, the two languages are very similar.\n\nOne notable exception is the {{code|IF}} in BASIC, which allowed any statement to be placed after the {{code|THEN}}, making it more similar with JOSS' control structures. BASIC reversed the ordering of the code compared to JOSS, placing the conditional expression at the start of the line rather than the end; in BASIC one uses {{code|IF this THEN that}} as opposed to {{code|that IF this}} in JOSS. BASIC's version has the advantage that the runtime could immediately abort reading the rest of the statement if the expression was not true. In contrast, FOCAL's {{code|IF}} was more like BASIC's [[computed goto]], {{code|ON X GOTO 10,20,30}}, but the {{code|ON...GOTO}} allowed any number of lines as targets, as opposed to only three for negative, zero and positive as in JOSS and FOCAL.\n\nAnother major difference between the two is that FOCAL lacked inherent support for [[string (computer science)|strings]] as data elements that could be assigned to variables. As was the case in early BASICs or FORTRAN versions before the addition of strings (in F77), this limitation was generally avoided through the use of literal strings in input and output commands. It was only when one had to manipulate individual strings or characters within them that this became a significant problem.\n\nAs string variables were not supported, inputting a string used a [[kludge]] that converted any characters typed in by the user to their numeric character value. For example, if one typed \"HELLO\" at an input statement, FOCAL would convert the H to \"8\", the numeric value of \"H\" in the PDP-8's [[six-bit character code]]s (\"H\" is the eighth letter). It would then interpret the \"E\" as starting an exponent, then it would try to compute \"8\" to the \"LLO\" power, which would take several seconds of CPU time and result in a value of 0.76593020E+103, not a particularly helpful response. Nevertheless, by asking questions that would be responded to using single-letter responses, like {{code|Do you need instructions, Y or N\"}}, programmers could test the result against known character values to produce what looked like character input.\n\nFOCAL's PDP-8 implementation used a [[Floating-point arithmetic|floating point]] representation that represented numbers as four 12-bit words, forty-eight bits in total, with thirty-six bits of mantissa and twelve bits of exponent. This allowed for both significantly higher precision and a significantly wider range of values than most contemporary interpreters, making FOCAL a reasonable choice for serious numerical work. This high precision, and good choices for default decimal output formatting, meant that difficulties with binary-to-decimal rounding were not evident to beginning users. For comparison, [[Microsoft BASIC]] initially used a [[Microsoft Binary Format|32-bit format]], while later versions expanded this to 40-bits. Most BASICs had problems with rounding that led to simple equations resulting in tiny non-zero remainders.\n\nIt is generally agreed that FOCAL was more efficient in its use of resources than comparable BASIC systems. On a typical machine of the day, often with 6 to 24 kilobytes of [[magnetic-core memory]], FOCAL could handle larger and more complex programming tasks than BASIC.\n\n== Versions and spinoffs ==\nThe Coca-Cola Corporation used a customized version of FOCAL called COKE.\n\nFOCAL was later implemented on the PDP-7, PDP-9, PDP-10, PDP-11, PDP-12, PDP-5 and LINC-8.\n\nThe FOCAL manual showed how to add commands to the FOCAL parser, so many sites added specialized commands for operating custom hardware.\n\nThe [[DECUS|Digital Equipment Computer Users' Society]] collected many patches and enhancements for FOCAL. There were even major enhanced offshoots of FOCAL, such as FOCAL-W, which added many features, including better mass storage file I/O and even virtual variable memory.\n\nIn [[Russia]], it saw use as late as the early 1990s in mass-produced home computers of the [[Electronika BK]] series.\n\n==Example code==\nThe original Lunar Lander makes an excellent example for examining FOCAL code, as it uses most of the features of the language. This code is from the original, found on [https://www.cs.brandeis.edu/~storer/LunarLander/LunarLander.html Jim Storer's Lunar Lander page].<ref>{{cite web |title=Lunar Lander |url=https://www.cs.brandeis.edu/~storer/LunarLander/LunarLander/LunarLanderListing.jpg |website= Lunar Landing Game Related Documents}}</ref>\n \n 01.04 T \"CONTROL CALLING LUNAR MODULE. MANUAL CONTROL IS NECESSARY\"!\n 01.06 T \"YOU MAY RESET FUEL RATE K EACH 10 SECS TO 0 OR ANY VALUE\"!\n 01.08 T \"BETWEEN 8 & 200 LBS/SEC. YOU'VE 16000 LBS FUEL. ESTIMATED\"!\n 01.11 T \"FREE FALL IMPACT TIME-120 SECS. CAPSULE WEIGHT-32500 LBS\"!\n 01.20 T \"FIRST RADAR CHECK COMING UP\"!!!;E\n 01.30 T \"COMMENCE LANDING PROCEDURE\"!\"TIME,SECS   ALTITUDE,\"\n 01.40 T \"MILES+FEET   VELOCITY,MPH   FUEL,LBS   FUEL RATE\"!\n 01.50 S A=120;S V=1;S M=32500;S N=16500;S G=.001;S Z=1.8\n \n 02.10 T \"    \",%3,L,\"       \",FITR(A),\"  \",%4,5280*(A-FITR(A))\n 02.20 T %6.02,\"       \",3600*V,\"    \",%6.01,M-N,\"      K=\";A K;S T=10\n 02.70 T %7.02;I (200-K)2.72;I (8-K)3.1,3.1;I (K)2.72,3.1\n 02.72 T \"NOT POSSIBLE\";F X=1,51;T \".\"\n 02.73 T \"K=\";A K;G 2.7\n \n 03.10 I (M-N-.001)4.1;I (T-.001)2.1;S S=T\n 03.40 I ((N+S*K)-M)3.5,3.5;S S=(M-N)/K\n 03.50 D 9;I (I)7.1,7.1;I (V)3.8,3.8;I (J)8.1\n 03.80 D 6;G 3.1\n \n 04.10 T \"FUEL OUT AT\",L,\" SECS\"!\n 04.40 S S=(FSQT(V*V+2*A*G)-V)/G;S V=V+G*S;S L=L+S\n \n 05.10 T \"ON THE MOON AT\",L,\" SECS\"!;S W=3600*V\n 05.20 T \"IMPACT VELOCITY OF\",W,\"M.P.H.\"!,\"FUEL LEFT:\"M-N,\" LBS\"!\n 05.40 I (1-W)5.5,5.5:T \"PERFECT LANDING !-(LUCKY)\"!;G 5.9\n 05.50 I (10-W)5.6,5.6;T \"GOOD LANDING-(COULD BE BETTER)\"!;G 5.9\n 05.60 I (22-W)5.7,5.7;T \"CONGRATULATIONS ON A POOR LANDING\"!;G 5.9\n 05.70 I (40-W)5.81,5.81;T \"CRAFT DAMAGE. GOOD LUCK\"!;G 5.9\n 05.81 I (60-W)5.82,5.82;T \"CRASH LANDING-YOU'VE 5 HRS OXYGEN\"!;G 5.9\n 05.82 T \"SORRY,BUT THERE WERE NO SURVIVORS-YOU BLEW IT!\"!\"IN \"\n 05.83 T \"FACT YOU BLASTED A NEW LUNAR CRATER\",W*.277777,\" FT.DEEP.\n 05.90 T !!!!\"TRY AGAIN?\"!\n 05.92 A \"(ANS. YES OR NO)\"P;I (P-0NO)5.94,5.98\n 05.94 I (P-0YES)5.92,1.2,5.92 \n 05.98 T \"CONTROL OUT\"!!!;Q\n \n 06.10 S L=L+S;S T=T-S;S M=M-S*K;S A=I;S V=J\n \n 07.10 I (S-.005)5.1;S S=2*A/(V+FSQT(V*V+2*A*(G-Z*K/M)))\n 07.30 D 9;D 6;G 7.1\n \n 08.10 S W=(1-M*G/(Z*K))/2;S S=M*V/(Z*K*(W+FSQT(W*W+V/Z)))+.05;D 9\n 08.30 I (I)7.1,7.1;D 6;I (-J)3.1,3.1;I (V)3.1,3.1,8.1\n \n 09.10 S Q=S*K/M;S J=V+G*S+Z*(-Q-Q^2/2-Q^3/3-Q^4/4-Q^5/5)\n 09.40 S I=A-G*S*S/2-V*S+Z*S*(Q/2+Q^2/6+Q^3/12+Q^4/20+Q^5/30)\n\nThe program is cleanly separated into a number of subroutines. This was almost universal in FOCAL programs (and JOSS), as the line number scheme made such constructs easy to use. This program uses nine routines. The first, group 1, simply prints out the instructions using the {{code|T}}ype statement and sets the initial values for the run. The mass of fuel is not recorded directly, instead, it uses the current {{code|M}}ass and empty mass, {{code|N}}, so the remaining fuel is M-N and the lander runs out of fuel when M-N is 0. Also note the {{code|E}}rase at the end of line 1.20, which resets all the variable values.\n\nThe main game loop is driven by group 2. As the code \"falls\" through group 1 into group 2 during the first run, the initial values are printed out in the first two lines. Near the end of line 2.20, the user is {{code|A}}sked to input the burn rate as {{code|K}}, and then the loop timer is reset using {{code|S T{{=}}10}}. Line 2.70 tests the user's input against several possibilities, if it is over 200 or below 8 it types \"NOT POSSIBLE\" and a row of periods, and then loops back to ask the user to try again. If the value is between these values, it jumps forward to group 3. Note that the limited capabilities of FOCAL's {{code|IF}} command are evident here, in BASIC this could be reduced to a single {{code|IF K>200 OR K<8 THEN...}}\n\nGroup 3 first tests to see if the fuel has run out, and jumps to group 4 if it has. Then it tests if the 10-second period in {{code|T}} has expired and, if so, loops back to print everything out again, which has the side-effect of resetting T and S to 10. Line 3.40 tests to see if the amount of fuel burned this period, S*K, will reduce the mass of the vehicle as a whole, S*K-M, beyond the empty weight, N. If not, it moves on, if it will, it instead sets the loop timer to the amount of time the remaining fuel will burn, thus ending the loop early. In either case, it calls group 9 to update the velocity and position. It then loops over groups 7, 8 and 9 until the value of I converges.\n\nWhen the 10-second timer runs out, or it reaches the end due to the fuel test in line 3.10 or the altitude test in 7.10. In the latter cases, it will jump to group 4 and fall through to group 5, or jump to group 5 directly. Group 5 types the end-of-game results and then asks the user if they'd like to try again. If so, it jumps to 1.20 to clear out all values and print the headers again, if not if falls through to 5.98 and {{code|Q}}uits.\n\n==See also==\n*[[JOSS]], the Rand language that inspired FOCAL\n*[[MUMPS]], a data-manipulation language based on JOSS and FOCAL concepts\n\n==References==\n{{Reflist}}\n\n===Bibliography===\n* {{cite book\n |title=FOCAL Programming Manual \n |publisher=Digital Equipment Corporation \n |date=1968 \n |url=http://www.bitsavers.org/www.computer.museum.uq.edu.au/pdf/DEC-08-AJAB-D%20PDP-8-I%20FOCAL%20Programming%20Manual.pdf \n|ref=CITEREFManual1968\n}}\n* {{cite web\n |url=https://www.gamasutra.com/view/news/216469/A_basic_history_of_BASIC_on_its_50th_birthday.php\n |title=A basic history of BASIC on its 50th birthday\n |website=Gamasutra\n |date=1 May 2014\n |first=John |last=Szczepaniak\n |ref=harv\n}}\n* {{cite interview\n |first=Kevin |last=Savetz\n |date=April 2013\n |title=Dave Ahl and Betsy Ahl\n |url=https://computingpioneers.com/index.php?title=Dave_Ahl_and_Betsy_Ahl\n |ref=harv\n}}\n\n==External links==\n*[ftp://ftp.pdp8.net/software/games/focal/ FOCAL source code], FOCAL source for several programs, including Lunar Lander, Sumer Game, and others\n*[http://www.cs.uiowa.edu/~jones/pdp8/focal/ DEC's FOCAL 1969 Promotional Booklet]\n*[http://simh.trailing-edge.com/ The Computer History Simulation Project (Focal is available as a free download here)]\n*ftp://www.cozx.com/pub/langs/focal.tar.gz C-source version that runs under several operating systems, including Linux\n*[http://www.catb.org/retro the C-source for a modern DOS version suitable for teaching]  \n*[https://web.archive.org/web/20110525101809/http://www.libex.ru/detail/book91959.html Abramov V.A. Dialogue language FOCAL] (in Russian) {{ISBN|5-06-001785-0}}\n*[https://web.archive.org/web/20080626062957/http://www.vntb.ru/kniga255.html Osetinsky L.G. FOCAL for mini-computers] (in Russian) {{ISBN|5-217-00323-5}}\n*[http://samlib.ru/u/uirh/kn_o_foc.shtml \u0424\u043e\u043a\u0430\u043b \u0441\u043d\u0430\u0440\u0443\u0436\u0438 \u0438 \u0438\u0437\u043d\u0443\u0442\u0440\u0438. (\u043f\u0438\u0448\u0435\u0442\u0441\u044f)]&nbsp;\u2014 FOCAL outside and inside. (in progress) (in Russian)\n*[http://samlib.ru/editors/u/uirh/foc_hlp.shtml \u0424\u0430\u0439\u043b \u0441\u043f\u0440\u0430\u0432\u043a\u0438 \u043a \u0444\u043e\u043a\u0430\u043b\u0443-1\u0431]&nbsp;\u2014 Help file for FOCAL-1B (in Russian)\n\n[[Category:JOSS programming language family]]\n[[Category:Digital Equipment Corporation]]\n", "text_old": "{{short description|Programming language used on DEC PDP-series machines}}\n{{For|the unrelated programming language on HP calculators|FOCAL (Hewlett-Packard)}}\n{{Infobox programming language\n| name = FOCAL\n| paradigm = \n| released = {{Start date and age|1968}}\n| developer = Richard Merrill, [[Digital Equipment Corporation|DEC]]\n| influenced by = [[JOSS]]\n| influenced = [[BASIC-PLUS]]\n| website = \n}}\n'''FOCAL''' is an interactive [[interpreter (computing)|interpreted]] [[programming language]] based on [[JOSS]] and primarily used on [[Digital Equipment Corporation]] (DEC) [[Programmed Data Processor|PDP-series]] machines. The name is an acronym for '''F'''ormulating '''O'''n-Line '''C'''alculations in '''A'''lgebraic '''L'''anguage.{{sfn|Manual|1968|p=1.1}}\n\nFOCAL is very similar to JOSS in terms of the commands it supports and the general syntax of the language. It differs in that many of JOSS' advanced features like [[Range (computer programming)|ranges]] and [[user-defined function]]s were removed to simplify the parser. Some of the keywords were renamed so that they all start with a unique first letter. This allows users to type in programs using single-character statements, further reducing memory needs. This was an important consideration on the [[PDP-8]], which was often limited to a few [[kilobyte]]s (KB).\n\nLike JOSS, and later BASICs, FOCAL on the PDP-8 was a complete environment that included a line editor, the interpreter, and input/output routines. The package as a whole was called '''FOCAL-8''', which also ran on the [[PDP-5]] and [[PDP-12]]. When ported to the [[PDP-11]], the resulting '''FOCAL-11''' relied on the underlying [[operating system]], [[RT-11]], to provide file support and editing. The language definition was updated twice, to '''FOCAL-69''' and a very slightly modified '''FOCAL-71'''. A port to the [[Intel 8080]] was also available.\n\nFOCAL is historically notable as the language for the original versions of the early [[video game]]s [[Hamurabi (video game)|''Hamurabi'']] and [[Lunar Lander (video game genre)|''Lunar Lander'']]. Both were later ported to BASIC where they became much more famous.<ref name=\"TIME\">{{cite web |url=http://time.com/69316/basic/ |title=Fifty Years of BASIC, the Programming Language That Made Computers Personal |work=[[Time (magazine)|Time]] |last=McCracken |first=Harry |date=2014-04-29 |access-date=2016-02-12 |archive-url=https://web.archive.org/web/20160205214236/http://time.com/69316/basic/ |archive-date=2016-02-05 |url-status=live}}</ref> FOCAL was not popular outside the PDP platform and largely disappeared during the move to the [[VAX-11]]. It had a strong revival in the [[Soviet Union]] where PDP-11 clones were used as educational and [[home computer]]s.\n\n==History==\n=== JOSS ===\n[[JOSS]] was released in May 1963 on the one-off [[JOHNNIAC]] computer at [[RAND Corporation]]. Within RAND, use grew rapidly, and the machine, originally constructed in 1953, quickly ran out of capability. JOHNNIAC retired in 1966 and JOSS moved to a newly purchased [[PDP-6]], [[Digital Equipment Corporation]]'s (DEC) first \"big\" machine. Usage continued to grow and by 1970 the system was being used by 500 to 600 users across the country and had spawned a number of innovations such as mobile [[computer terminal]]s that could be wheeled from room to room and plugged in for instant access.<ref name=rand>{{cite techreport |url=https://www.rand.org/content/dam/rand/pubs/reports/2008/R918.pdf |title=The JOSS Years: Reflections on an experiment |first=Shirley |last=Marks |date=December 1971 |publisher=Rand}}</ref>\n\nJOSS was extremely influential in the computer field. It emerged just as the [[time-sharing]] concept was being introduced and there was significant interest in man-machine interaction and computers were seeing more widespread use. Whereas most timeshare [[operating system]]s of the era concentrated on user account and file management, leaving the users on their own when it came to programming, JOSS provided these functions and an easily used programming language in a single package. RAND showed the system to a parade of people in the industry.<ref name=rand/>\n\n===FOCAL===\nPorts of JOSS to other platforms began to appear shortly after the PDP-6 version was released. FOCAL was one example of its many offshoots.\n\nWritten by [[Richard Merrill]], FOCAL removed features as required in order to be able to run in the much more limited memory space of the [[PDP-8]] and other 12-bit machines in the DEC lineup. To achieve this, a major change was made to reduce the amount of temporary data, or \"[[State (computer science)|state]]\", needed to parse the statements. One noticeable effect of this decision was that [[Conditional (computer programming)|conditionals]] could only be used for [[Branch (computer science)|branches]], in contrast to JOSS, where conditionals can be applied to any statement.\n\nThe other noticeable change was to rearrange the keywords so each started with a unique letter. This simplified the [[Parsing|parser]], which needed to read only the first letter of the command on a line of code, and could then skip forward to the next blank. In contrast, JOSS had to continue reading until it had read the entire command word, and then compare that against a list containing complete words. Users could save memory by typing in only that letter, reducing the size of the [[source code]].\n\nThe first version of FOCAL was released in 1968 for the [[PDP-8]]. An updated version followed the next year, which was later known as FOCAL-69. The system as a whole, regardless of version, was known as FOCAL-8 when it was ported to other machines in the 12-bit series, including the [[PDP-5]] and [[PDP-12]]. It was popular as it was highly efficient in terms of memory use, which was often severely limited on these machines to a few [[kilobyte]]s (KB). The similar FOCAL-11 ran on the [[PDP-11]] under [[RT-11]].\n\n[[Processor Technology]] also offered a version of 8k FOCAL, complete with Lunar Lander, for the [[Intel 8080]]-based [[Altair 8800]] system. This was provided for the copying charge of the tape, while the [[source code]] was provided for free with other purchases.<ref>{{cite magazine |url=https://archive.org/details/byte-magazine-1976-04/page/n49 |title=Watch Your Altair Grow! |magazine=Byte |date=April 1976 |page=48}}</ref>\n\n===BASIC===\nWhile FOCAL was becoming popular on DEC machines, BASIC was becoming a more popular alternative on other platforms. By the late 1960s, a number of companies were making inroads in DEC's minicomputer stronghold selling similar machines running timeshared versions of BASIC. Notable among these was the [[HP 2100]] series, running [[HP Time-Shared BASIC]].{{sfn|Szczepaniak|2014}}\n\n[[David H. Ahl]] had recently joined DEC's PDP-8 Group, just as the company became interested in selling the machine into educational settings. Due to the popularity of BASIC in the educational market, especially with the growing library of BASIC programs from the [[Minnesota Educational Computing Consortium]], Ahl found selling the machine with FOCAL was difficult in spite of its advantages.{{sfn|Szczepaniak|2014}} As he later noted:\n\n{{Quote | style=font-size:100% | |DEC's FOCAL language was equal to BASIC in most aspects and even better in some, but it had one huge drawback: DEC was unwilling to license it to other computer manufacturers. FOCAL was fighting an uphill battle against BASIC, which was available on GE, Honeywell, HP, and other computers.<br /><br />I think it wound up with a situation like Sony and Betamax. Sony saying, \"Betamax is ours and it is a better format than VHS,\" which it was. But then, JVC saying, \"We have VHS and Toshiba. Hey, do you want to use it? Fine, we'll license it to you for next to nothing.\"{{sfn|Szczepaniak|2014}}}}\n\nAhl took it upon himself to produce a BASIC system for the platform, hiring a company he later learned was a single programmer in Brooklyn to produce a version for the 4&nbsp;kWord PDP-8. DEC began selling packaged versions of the PDP-8 with terminals and the BASIC as the \"EduSystem\" lineup, with larger systems in the series having expanded versions of BASIC, and in some cases, FOCAL and [[FORTRAN]] as well. Some PDP-11 based EduSystems were also created.<ref name=edu>{{cite book |url=http://bitsavers.trailing-edge.com/pdf/dec/pdp8/tss8/EduSystemHandbookJan73.pdf |title=EduSystem Handbook |page=V |publisher=Digital |date=1973}}</ref>\n\nAhl then began porting programs from FOCAL to BASIC, notably [[Hamurabi (video game)|''The Sumer Game'']] (which he renamed ''Hamurabi''), a version of [[Lunar Lander (video game genre)|''Lunar Lander'']], and a number of smaller FOCAL demos. Combining his ports with submissions from outside programmers, he managed to collect enough material to have DEC publish ''101 BASIC Computer Games'' in 1973. The book was an immediate success and ultimately ran through three printings to 1975.{{sfn|Savetz|2013}}{{sfn|Szczepaniak|2014}}\n\nBy the mid-1970s BASIC was a standard feature of all DEC machines and FOCAL use evaporated.{{sfn|Savetz|2013}}\n\n===Rebirth in the Soviet Union===\nThe PDP-11 had been cloned in the [[Soviet Union]] in the 1970s for military purposes. In the 1980s, single-chip variations similar to the [[LSI-11]] were produced that gave rise to a series of PDP-11 compatible [[home computer]]s. Most notable among several models were the [[Electronika BK]] series, released in 1985. These were initially supplied with FOCAL on a [[ROM cartridge]],<ref>{{cite techreport|url=https://www.ucis.pitt.edu/nceeer/1988-802-8-Stapleton.pdf |title=The Soviet Union and the Personal Computer \"Revolution\" |page=8 |first1=R.A. |last1=Stapleton |first2=S.E. |last2=Goodman |date=June 1988 |publisher=University of Arizona}}</ref> while a BASIC cartridge was an optional add-on. Later models supplied BASIC by default.<ref>{{cite web |url=https://oldcomputermuseum.com/elektronika_bk0010.html |title=Elektronika BK-0010 |website=Old Computer Museum}}</ref>\n\n==Language==\nThe following description is based on FOCAL-69 as seen in the FOCAL-8 language reference manual.{{sfn|Manual|1968}}\n\n===Direct and indirect modes===\nFOCAL followed the JOSS model for interaction via a [[command line interface]]. This allowed users to type in commands in \"direct mode\", which were performed immediately, or to prefix them with a line number, in which case they were added to the program if they were unique, or overrode existing code if the same number had previously been used.{{sfn|Manual|1968|p=2.1}}\n\nThe method of operation is similar to BASIC's \"immediate mode\" vs. \"program mode\". It contrasts with JOSS, in which all commands, both program and direct, were saved and loaded as part of the user's workspace. This allowed JOSS to have commands without line numbers, which they used for {{code|Form}} definitions and other tasks. FOCAL lacked this capability, so those instructions that needed to be loaded and saved became options on other program-mode commands like {{code|Type}}.{{sfn|Manual|1968|p=2.1}}\n\n===Program statements===\nEvery line in a FOCAL program must start with a line number. As with JOSS, line numbers are fixed-point numbers consisting of two two-digit integers separated by a period. In FOCAL-8, valid line numbers range from 1.01 through 31.99. When printed out, using {{code|WRITE}}, the FOCAL equivalent to BASIC's {{code|LIST}}, leading zeros will be added so that all line numbers. This means all line numbers will be a total of five characters including the period; 1.10 will be printed as {{code|01.10}}. Statements referring to those lines do not need the leading zeros, for instance, {{code|GOTO 1.10}}.{{sfn|Manual|1968|p=2.7}}\n\nThe number on the left of the period is known as the \"group number\". Groups provide some level of code organization that is lacking in languages like Fortran or BASIC. The primary use of these was to use a group as a [[subroutine]] which can be called with {{code|DO}}, for instance, {{code|DO 5}} which will jump to the subroutine written in group 5. The editor also used these during edit-time, for instance, one could {{code|WRITE 2}} to produce a listing of the code in group 2, or {{code|ERASE 4}} to delete all of the lines in group 4.{{sfn|Manual|1968|p=2.7}}\n\nEvery line must start with a command keyword following the line number.{{sfn|Manual|1968|p=2.7}} There is no concept of a \"default command\" as is the case in BASIC with its optional {{code|LET}} statement. Multiple statements can be placed on a single line, separated by semicolons. Usually, the behavior is no different than if the statements had been on separate lines, except in the case of FOR loops.{{sfn|Manual|1968|p=3.7}}\n\n=== Commands ===\n====ASK====\nThe {{code|ASK}} command (abbreviation A) will take a list of strings and variables, echo the strings and store the user input in variables.{{sfn|Manual|1968|p=3.2}} Equivalent to BASIC's {{code|INPUT}}.\n\n 01.01 ASK \"NAME\", NAME\n 01.02 ASK \"COORDINATES\", X, Y\n 01.03 ASK \"A1\",A1,\"OMEGA\",W,\"T0\",T0,\"DAMPING FACTOR\",DAMPINGFACTOR\n\nIf the user doesn't enter a number but enters text, the system will convert the initial character to a number with \"A\"=1, \"B\"=2, etc.\n\n====COMMENT====\nThe {{code|COMMENT}} command (abbreviation C) creates a remark.{{sfn|Manual|1968|p=3.6}} Equivalent to BASIC's {{code|REM}}.\n 01.01 COMMENT: THE SUMER GAME, BY RICHARD MERRILL\n\n====DO====\nThe {{code|DO}} command (abbreviation D) branches execution to a subroutine. It is the equivalent of BASIC's {{code|GOSUB}}. The subroutine is referenced either by group number or line number. If a line number is provided, that single line is run and then returns to the statement after the {{code|DO}}. If no line number is provided, execution starts at the first line of the block and continues until the end of the block is reached or a {{code|RETURN}} is encountered. {{code|RETURN}} is only required to return early from the group, it is not needed at the end of the group.{{sfn|Manual|1968|p=3.4}}\n 01.15 DO 7.24\n 01.16 DO 8\n\n====FOR====\nThe {{code|FOR}} command (abbreviation F) implements a [[for loop]]. When three arguments are specified, the first is the initial value of the loop variable, the second is the increment, and the third value is the terminating value for the loop. If two values are provided, the first is the initial value and the second is the terminating value, and the increment is set to 1.\n\nIn contrast to other parts of the language where multiple statements on a line are independent, the {{code|FOR}} always runs the statements that follow it on the line before the termination has been met, and then continues to the next line. Thus, loops have to be on a single line, or alternately, call a subroutine with {{code|DO}}. There is no equivalent of BASIC's {{code|NEXT}}.{{sfn|Manual|1968|p=3.7}}\n 01.01 FOR X=1,10; TYPE X,!\n 01.02 FOR X=0,10,100; DO 2\n\nA sample FOR loop:\n 01.10 ASK \"HOW MUCH MONEY DO YOU WANT TO BORROW ?\",PRINCIPAL\n 01.20 ASK \"FOR HOW MANY YEARS ?\",TERM\n 01.30 FOR RATE=4.0,.5,10;DO 2.0\n 01.40 QUIT\n 02.10 SET INTEREST=PRINCIPAL*(RATE/100)*TERM\n 02.20 TYPE \"RATE\",RATE,\"   \",\"INTEREST\",INTEREST,!\n\n====GOTO====\nThe {{code|GOTO}} command (abbreviation G) jumps program execution to the specified line number.{{sfn|Manual|1968|p=3.4}} It is identical to the same-named statement in BASIC. In FOCAL, {{code|GOTO}} is also used to begin execution, like BASIC's {{code|RUN}}, but in this usage, the documentation refers to it as {{code|GO}} instead of {{code|GOTO}} in spite of the underlying command being the same.\n 01.05 GOTO 1.01\n 02.90 TYPE !!,\"TRY AGAIN.\",!!!!!;GOTO 1.1\n\n====IF====\nThe {{code|IF}} command (abbreviation I) provides a conditional branch based on the sign of the expression. After the numeric expression, the IF command can take one to three line numbers. If the expression is less than zero, execution branches to the first line number;  if equal to zero, to the second line number;  if greater than zero, to the third line number. The language lacked relative operators such as greater than, equal or less than. To branch if X > 5, one must compare X - 5.{{sfn|Manual|1968|p=3.5}}\n 02.20 IF (25-25) 2.4,2.3,2.4\n 03.01 IF (X) 3.1,3.02,3.1\n\nIF could be short-formed by placing a semicolon (or end of line) beyond the first line number. For instance:\n\n 02.20 IF (X)1.8; TYPE \"Q\"\n 02.30 IF (X)1.8,2.50\n 02.40 TYPE \"P\"\n\nIn this case the test at 2.20 will cause the program to jump to line 1.8 if the test is negative, otherwise it will continue and type \"Q\" to the console. Line 2.30 will jump to 1.8 or 2.5 if the value is negative or zero, and otherwise continue to type \"P\" to the console.{{sfn|Manual|1968|p=3.5}}\n\n====QUIT====\nThe {{code|QUIT}} command (abbreviation Q) terminates execution of the program and returns control to the editing environment.{{sfn|Manual|1968|p=3.6}} Equivalent to BASIC's {{code|STOP}} or {{code|END}}.\n 01.10 FOR X=-10,1,10;TYPE X\n 01.20 QUIT\n\n====RETURN====\nThe {{code|RETURN}} command (abbreviation R) branches execution from a subroutine back to the calling location.{{sfn|Manual|1968|p=3.6}} The use of {{code|RETURN}} is optional at the last line of a subroutine, a subroutine returns at the last line in the group anyway. The following is a sample subroutine for converting a yes/no prompt into a value.[http://www.pdp8.net/lang/focal/misc.shtml]\n 22.78 COMMENT: 'YES OR NO' SUBROUTINE\n 22.80 ASK \"ANSWER YES OR NO ?  \",AN\n 22.82 IF (AN-0YES)22.84,22.86\n 22.84 IF (AN-0NO)22.8,22.88,22.8\n 22.86 SET X=2;RETURN\n 22.88 SET X=1;RETURN\n\n====SET====\nThe {{code|SET}} command (abbreviation S) assigns the results of an expression to the specified variable.{{sfn|Manual|1968|p=3.3}} Equivalent to BASIC's {{code|LET}}.\n 01.30 SET PI=3.14156\n 01.60 SET INTEREST=PRINCIPAL*(RATE/100)*TERM\n\n====TYPE ====\nThe {{code|TYPE}} command (abbreviation T) provides for output of one or more items separated by commas.{{sfn|Manual|1968|p=3.1}} Equivalent to BASIC's {{code|PRINT}}.\n\nItems can be variables, literal strings surrounded by double-quotes, or a variety of control characters. The control characters include the {{code|!}} to output a carriage return and line feed, {{code|#}} for the carriage return alone, and {{code|:}} for a tab character. Control characters can be strung together, for instance, {{code|!!!}} will output three CR/LFs without the need to separate them with commas.{{sfn|Manual|1968|p=3.2}}\n\n TYPE [NUMBERS, E1, \"TEXT\", !, #, :, $ OR %] ...OUTPUT\n 01.10 TYPE \"HI THERE, GOOD LOOKING.  HOW MUCH MONEY DO YOU WANT TO BORROW?\",!\n 01.50 TYPE \"INTEREST\",INTEREST,!\n 01.80 TYPE \"THE INTEREST FOR\",TERM,\" YEARS\",!,\"IS\",INTEREST, \" DOLLARS.\",!!\n 01.90 TYPE \"NEW YORK\",!,\"WASHINGTON\",!,\"ATLANTA\",!,\"DALLAS\",!\n 02.10 TYPE \"X\",X,\"   \",\"X^2\",X^2,\"   \",\"SQRT\",FSQT(X)\n 03.20 TYPE \".\",#\n 02.20 TYPE !!!!!\n\n{{code|TYPE}} also included an optional format specifier indicated using the format {{code|%x.yz}}, where x is the number of digits to the left of the decimal, and yz is the number of digits to the right of the period. The default format was {{code|%8.4}}, meaning a maximum of eight digits and four to the right of the period.{{sfn|Manual|1968|p=2.2}} So, for instance:\n\n SET A=67823\n TYPE %6.01,A\n =  67823.0\n TYPE %5,A\n = 67823\n TYPE %8.03,A\n =   67823.000\n TYPE %,A\n = 6.7823E4\n\nNote the extra leading spaces in some examples, padding out the full defined width. Using % alone caused the output to be printed in \"floating point format\" using the E.{{sfn|Manual|1968|p=2.3}}\n\nA special control character was {{code|$}} which caused a table of all defined variables and their values to be printed. Only the first two letters of the name will be printed, padded with a zero if need be. Arrays elements are printed on separate lines and variables with only one element will be indexed (00). For example:{{sfn|Manual|1968|p=2.5}}\n\n TYPE $\n A0(00)=67823\n\n=== Variables ===\nVariable names may start with any letter except F (F is reserved for functions) and may contain any sequence of letters and numbers. However, only the first two characters are significant. For instance, the following code sample from ''FOCAL: A New Conversational Language''<ref>{{cite book |title=FOCAL: A New Conversational Language |url=http://www.cs.uiowa.edu/~jones/pdp8/focal/focal69.html |publisher=Digital}}</ref> refers to the same variable as DESTINATION and then DES. Internally, both references refer to a variable designated DE:\n 01.80 ASK DESTINATION\n 02.30 IF (DES-14) 2.4,3.1,2.4\n\nAny variable may be treated as an array, allowing subscripts from -2048 through 2047.[http://www.pdp8.net/lang/focal/misc.shtml]\n\n=== Math ===\nFOCAL-69 contained only five mathematical operators:{{sfn|Manual|1968|p=2.4}}\n* {{code|^}} for exponents - the exponent is converted to a 12-bit integer\n* {{code|*}} for multiplication\n* {{code|/}} for division\n* {{code|+}} for addition\n* {{code|-}} for subtraction\n\nOne curiosity of FOCAL was that the operators all had independent precedence, as in the order above. That means that the formula {{code|SET T{{=}}2-3+1}}, it would be evaluated in the order 2-(3+1) and thus produce -2. This was very different than most languages, where the + and - had equal precedence and would be evaluated (2-3)+1 to produce 0.{{sfn|Manual|1968|p=2.4}} This can cause subtle errors when converting FOCAL source code to other systems.\n\nFOCAL was unusual in that mathematical expressions could use (), [] and <> interchangeably in matched pairs to establish precedence.{{sfn|Manual|1968|p=2.4}} For instance, the following is a valid expression:\n\n   01.30 SET A=<10*[5+1]*(1+5)>\n\nAll of these are the same level of precedence and read left-to-right when at the same level, so this statement will be evaluated [], then (), then <>, to produce 360.{{sfn|Manual|1968|p=2.4}}\n\nThe language contained the following built-in functions:{{sfn|Manual|1968|p=3.10}}\n* {{code|FABS()}} - Absolute value\n* {{code|FATN()}} - Arctangent\n* {{code|FCOS()}} - Cosine of argument in radians\n* {{code|FEXP()}} - Natural base to the power of the argument\n* {{code|FITR()}} - Integer part of the argument\n* {{code|FLOG()}} - Naperian log\n* {{code|FRAN()}} - Random number\n* {{code|FSGN()}} - Sign of the argument; FSGN(0)=1 in FOCAL-69, but FSGN(0)=0 in FOCAL-71 as well as later versions\n* {{code|FSIN()}} - Sine of an angle given in radians\n* {{code|FSQT()}} - Square root\n\n===Other functions===\nFOCAL also included a number of special-purpose functions:{{sfn|Manual|1968|p=A.3}}\n\n* {{code|FDIS}} took two values and plotted a dot on the screen of graphical terminals\n* {{code|FADC}} read a value from a numbered analog input and returned an integer value\n\n==Environment commands==\n====Running programs====\nFOCAL used {{code|GOTO}} in the editor to start a program. However, a rule-of-thumb was to shorten this to {{code|GO}}. This is the equivalent of {{code|RUN}} in BASIC. {{code|GOTO}} can also be used in the editor to start execution at a specified line.\n\n====Editing commands====\nNew lines are entered into the program by simply beginning the command with a line number.  The editing commands were ERASE (abbreviation E),{{sfn|Manual|1968|p=2.4}} MODIFY (abbreviation M){{sfn|Manual|1968|p=3.8}} and WRITE (abbreviation W):{{sfn|Manual|1968|p=3.2}}\n* <code>ERASE</code> - zeroes out all variables. this is sometimes found within programs to reset them\n* <code>ERASE ''line number''</code> - deletes the statement at the specified line\n* <code>ERASE ''group number''</code> - deletes all statements in the specified group\n* <code>ERASE ALL</code> - deletes the entire program\n* <code>MODIFY ''line number''</code> - allows the programmer to edit the specified line\n* <code>WRITE ''line number''</code> - display the statement at the specified line\n* <code>WRITE ''group number''</code> - display all statements in the specified group\n* <code>WRITE ALL</code> - display the specified program\n\n====File commands====\nThe file command was OPEN (abbreviation O):\n* {{code|OPEN INPUT [device:][file][,ECHO]}} - prepare to read from the start of a file\n* {{code|OPEN OUTPUT [device:][file][,ECHO]}} - prepare to write from the start of a file\n* {{code|OPEN RESTORE INPUT[,ECHO]}} - resume input\n* {{code|OPEN RESTORE OUTPUT[,ECHO]}} - resume output\n* {{code|OUTPUT CLOSE}} - output the buffer and close the file\n\n====Library commands====\nFOCAL included the ability to manage collections of FOCAL programs as a code library. Programs could call other programs in a chain fashion using {{code|LIBRARY CALL}}, or call a single subroutine in another program using {{code|LIBRARY GOSUB}}. Program names could be six characters long. The LIBRARY command (abbreviation L) had the following sub-commands:\n\n* {{code|LIBRARY DELETE [device:]<nowiki><program name></nowiki>}} - delete a program\n* {{code|LIBRARY LIST [device:][file name]}} - catalog\n* {{code|LIBRARY RUN [device:]<nowiki><program name></nowiki> [line number]}} - chain the program, optionally resuming at the specified line number\n* {{code|LIBRARY SAVE [device:]<nowiki><program name></nowiki>}} - save the program\n* {{code|LIBRARY EXIT}} - return to the PDP-8 monitor program\nFOCAL-71 added:\n* {{code|LIBRARY CALL [device:]<nowiki><program name></nowiki>}} - load a program\n* {{code|LIBRARY GOSUB [device:]<nowiki><program name></nowiki> [group number]}} - call a subroutine in an external program\n\n==Error codes==\nSince the interpreter lacked sufficient memory space to store error messages, or even a table of error numbers, FOCAL used a workaround by reporting the address of the error-detecting code as a fixed-point number. For example, the [[division by zero]] error was detected it would report {{code|?28.73 @ 01.10}}, where 28.73 represents the code checking for this error at memory page 28 plus an offset of 73 words, and 01.10 is the line number where the error occurred. Pages in the PDP-8 were 128 bytes long, so this address translates to location 3657.\n\n==Changes between versions==\nDEC released three versions of FOCAL for the PDP-8 series, the original, known simply as FOCAL, and two updated versions, \nFOCAL,1969 and FOCAL,1971. FOCAL,1969 was largely identical to the original, but FOCAL,1971 was major update that added file handling, new mathematics, and a variety of other changes. In contrast to the first two versions, which were stand-alone systems, FOCAL,1971 was based on the emerging [[OS/8]] (then still known as PS/8) and relied more heavily on that operating system for file handling and editing.\n\n===FOCAL,1971===\nOne change in the new version was a 10-digit math package for added precision. The {{code|FSGN}} function now returned zero if the input expression evaluated to zero. Previously this would return one. The {{code|FRAN}} now used a better algorithm that produced more randomly distributed numbers. It also added the new {{code|FIN}} function that took a string and returned its [[ASCII]] value (akin to BASIC's {{code|ASC}}) and {{code|FOUT}} which took a number and returned a string with that ASCII character ({{code|CHR}}.\n\nAs all of these options used up limited memory, when started, FOCAL,1971 entered a dialog that asked the user what features they wanted to use.\n\n==Comparison with JOSS==\nFOCUL is, for all intents, a cleaned-up version of JOSS with changes to make the syntax terser and easier to parse. Almost all FOCAL commands have a one-to-one correspondence with JOSS and differ only in details. A few features of JOSS were missing in FOCAL.\n\nOne major difference is that JOSS included a complete set of comparison operations and a [[boolean logic]] system that operated within if and for constructs. Furthermore, the ifs and loops could be applied to any statement, in contrast to FOCAL, where the only operation either could carry out was the equivalent to a goto. For instance, in JOSS, one could:\n\n  1.10 Type A if X>10.\n  1.20 Type i for i=1(1)10.\n\nWhich would optionally print A based on the test, and then print the numbers 1 to 10. In contrast, FOCAL lacked the ability to compare values, and loops were applied by skipping to the next line when they completed. The equivalent code in FOCAL would be:\n\n 1.10 IF (X-10) ,,1.30\n 1.20 TYPE A!\n 1.30 FOR I=1,1,10;TYPE I,!\n\nJOSS' implementation makes common constructs easier to build and more closely match the programmer's intentions, at the cost of making the runtime more complex. For instance, JOSS allowed ranges in loops to be described in a flexible fashion, for instance, 1,2,3,10(5)50,75,78. This flexibility comes at a cost; in FOCAL the start, stop and step can be written down in a custom in-memory structure and easily updated as the loop is performed. In contrast, the JOSS system requires a pointer to what might be, but often isn't, a more complex expression that has to be stepped over with more complex parsing code.\n\nIn terms of making the code terser, changes were relatively minor. For instance, JOSS' {{code|Do part 20.}} becomes the slightly smaller FOCAL {{code|DO 20}}, while {{code|Do step 20.1}} becomes {{code|DO 20.1}}. Command keywords were also shortened where possible, so JOSS' {{code|Demand}} becomes FOCAL's {{code|ASK}}, both to make it shorter as well as allow the letter D to be uniquely used for {{code|DO}}. The period needed to indicate the end of a line in JOSS was removed.\n\nTo simplify the parser, some FOCAL options were removed. For instance, JOSS could perform multiple assignments with {{code|Set S{{=}}P, P{{=}}Q, Q{{=}}S.}} while in FOCAL these had to be made individual statements, {{code|SET S{{=}}P; SET P{{=}}Q; SET Q{{=}}S}}. Likewise, JOSS' {{code|Form}}, used to format output, was combined into FOCAL's {{code|TYPE}} with the {{code|%}}.\n\n==Comparison with BASIC==\nComparisons between FOCAL and BASIC were inevitable since both languages were common on [[minicomputer]]s of the same era, and the two languages have much in common in terms of syntax and structure. In most cases, there is a direct conversion of FOCAL code to and from BASIC. For instance, to ask the user to input a value, in FOCAL one would:\n\n  ASK \"What is your age?\",AGE\n\nwhile in BASIC the equivalent is:\n\n  INPUT \"What is your age?\",AGE\n\nWith the exception of a few features that were missing from one or the other, and some relatively minor differences in syntax, the two languages are very similar.\n\nOne notable exception is the {{code|IF}} in BASIC, which allowed any statement to be placed after the {{code|THEN}}, making it more similar with JOSS' control structures. BASIC reversed the ordering of the code compared to JOSS, placing the conditional expression at the start of the line rather than the end; in BASIC one uses {{code|IF this THEN that}} as opposed to {{code|that IF this}} in JOSS. BASIC's version has the advantage that the runtime could immediately abort reading the rest of the statement if the expression was not true. In contrast, FOCAL's {{code|IF}} was more like BASIC's [[computed goto]], {{code|ON X GOTO 10,20,30}}, but the {{code|ON...GOTO}} allowed any number of lines as targets, as opposed to only three for negative, zero and positive as in JOSS and FOCAL.\n\nAnother major difference between the two is that FOCAL lacked inherent support for [[string (computer science)|strings]] as data elements that could be assigned to variables. As was the case in early BASICs or FORTRAN versions before the addition of strings (in F77), this limitation was generally avoided through the use of literal strings in input and output commands. It was only when one had to manipulate individual strings or characters within them that this became a significant problem.\n\nAs string variables were not supported, inputting a string used a [[kludge]] that converted any characters typed in by the user to their numeric character value. For example, if one typed \"HELLO\" at an input statement, FOCAL would convert the H to \"8\", the numeric value of \"H\" in the PDP-8's [[six-bit character code]]s (\"H\" is the eighth letter). It would then interpret the \"E\" as starting an exponent, then it would try to compute \"8\" to the \"LLO\" power, which would take several seconds of CPU time and result in a value of 0.76593020E+103, not a particularly helpful response. Nevertheless, by asking questions that would be responded to using single-letter responses, like {{code|Do you need instructions, Y or N\"}}, programmers could test the result against known character values to produce what looked like character input.\n\nFOCAL's PDP-8 implementation used a [[Floating-point arithmetic|floating point]] representation that represented numbers as four 12-bit words, forty-eight bits in total, with thirty-six bits of mantissa and twelve bits of exponent. This allowed for both significantly higher precision and a significantly wider range of values than most contemporary interpreters, making FOCAL a reasonable choice for serious numerical work. This high precision, and good choices for default decimal output formatting, meant that difficulties with binary-to-decimal rounding were not evident to beginning users. For comparison, [[Microsoft BASIC]] initially used a [[Microsoft Binary Format|32-bit format]], while later versions expanded this to 40-bits. Most BASICs had problems with rounding that led to simple equations resulting in tiny non-zero remainders.\n\nIt is generally agreed that FOCAL was more efficient in its use of resources than comparable BASIC systems. On a typical machine of the day, often with 6 to 24 kilobytes of [[magnetic-core memory]], FOCAL could handle larger and more complex programming tasks than BASIC.\n\n== Versions and spinoffs ==\nThe Coca-Cola Corporation used a customized version of FOCAL called COKE.\n\nFOCAL was later implemented on the PDP-7, PDP-9, PDP-10, PDP-11, PDP-12, PDP-5 and LINC-8.\n\nThe FOCAL manual showed how to add commands to the FOCAL parser, so many sites added specialized commands for operating custom hardware.\n\nThe [[DECUS|Digital Equipment Computer Users' Society]] collected many patches and enhancements for FOCAL. There were even major enhanced offshoots of FOCAL, such as FOCAL-W, which added many features, including better mass storage file I/O and even virtual variable memory.\n\nIn [[Russia]], it saw use as late as the early 1990s in mass-produced home computers of the [[Electronika BK]] series.\n\n==Example code==\nThe original Lunar Lander makes an excellent example for examining FOCAL code, as it uses most of the features of the language. This code is from the original, found on [https://www.cs.brandeis.edu/~storer/LunarLander/LunarLander.html Jim Storer's Lunar Lander page].<ref>{{cite web |title=Lunar Lander |url=https://www.cs.brandeis.edu/~storer/LunarLander/LunarLander/LunarLanderListing.jpg |website= Lunar Landing Game Related Documents}}</ref>\n \n 01.04 T \"CONTROL CALLING LUNAR MODULE. MANUAL CONTROL IS NECESSARY\"!\n 01.06 T \"YOU MAY RESET FUEL RATE K EACH 10 SECS TO 0 OR ANY VALUE\"!\n 01.08 T \"BETWEEN 8 & 200 LBS/SEC. YOU'VE 16000 LBS FUEL. ESTIMATED\"!\n 01.11 T \"FREE FALL IMPACT TIME-120 SECS. CAPSULE WEIGHT-32500 LBS\"!\n 01.20 T \"FIRST RADAR CHECK COMING UP\"!!!;E\n 01.30 T \"COMMENCE LANDING PROCEDURE\"!\"TIME,SECS   ALTITUDE,\"\n 01.40 T \"MILES+FEET   VELOCITY,MPH   FUEL,LBS   FUEL RATE\"!\n 01.50 S A=120;S V=1;S M=32500;S N=16500;S G=.001;S Z=1.8\n \n 02.10 T \"    \",%3,L,\"       \",FITR(A),\"  \",%4,5280*(A-FITR(A))\n 02.20 T %6.02,\"       \",3600*V,\"    \",%6.01,M-N,\"      K=\";A K;S T=10\n 02.70 T %7.02;I (200-K)2.72;I (8-K)3.1,3.1;I (K)2.72,3.1\n 02.72 T \"NOT POSSIBLE\";F X=1,51;T \".\"\n 02.73 T \"K=\";A K;G 2.7\n \n 03.10 I (M-N-.001)4.1;I (T-.001)2.1;S S=T\n 03.40 I ((N+S*K)-M)3.5,3.5;S S=(M-N)/K\n 03.50 D 9;I (I)7.1,7.1;I (V)3.8,3.8;I (J)8.1\n 03.80 D 6;G 3.1\n \n 04.10 T \"FUEL OUT AT\",L,\" SECS\"!\n 04.40 S S=(FSQT(V*V+2*A*G)-V)/G;S V=V+G*S;S L=L+S\n \n 05.10 T \"ON THE MOON AT\",L,\" SECS\"!;S W=3600*V\n 05.20 T \"IMPACT VELOCITY OF\",W,\"M.P.H.\"!,\"FUEL LEFT:\"M-N,\" LBS\"!\n 05.40 I (1-W)5.5,5.5:T \"PERFECT LANDING !-(LUCKY)\"!;G 5.9\n 05.50 I (10-W)5.6,5.6;T \"GOOD LANDING-(COULD BE BETTER)\"!;G 5.9\n 05.60 I (22-W)5.7,5.7;T \"CONGRATULATIONS ON A POOR LANDING\"!;G 5.9\n 05.70 I (40-W)5.81,5.81;T \"CRAFT DAMAGE. GOOD LUCK\"!;G 5.9\n 05.81 I (60-W)5.82,5.82;T \"CRASH LANDING-YOU'VE 5 HRS OXYGEN\"!;G 5.9\n 05.82 T \"SORRY,BUT THERE WERE NO SURVIVORS-YOU BLEW IT!\"!\"IN \"\n 05.83 T \"FACT YOU BLASTED A NEW LUNAR CRATER\",W*.277777,\" FT.DEEP.\n 05.90 T !!!!\"TRY AGAIN?\"!\n 05.92 A \"(ANS. YES OR NO)\"P;I (P-0NO)5.94,5.98\n 05.94 I (P-0YES)5.92,1.2,5.92 \n 05.98 T \"CONTROL OUT\"!!!;Q\n \n 06.10 S L=L+S;S T=T-S;S M=M-S*K;S A=I;S V=J\n \n 07.10 I (S-.005)5.1;S S=2*A/(V+FSQT(V*V+2*A*(G-Z*K/M)))\n 07.30 D 9;D 6;G 7.1\n \n 08.10 S W=(1-M*G/(Z*K))/2;S S=M*V/(Z*K*(W+FSQT(W*W+V/Z)))+.05;D 9\n 08.30 I (I)7.1,7.1;D 6;I (-J)3.1,3.1;I (V)3.1,3.1,8.1\n \n 09.10 S Q=S*K/M;S J=V+G*S+Z*(-Q-Q^2/2-Q^3/3-Q^4/4-Q^5/5)\n 09.40 S I=A-G*S*S/2-V*S+Z*S*(Q/2+Q^2/6+Q^3/12+Q^4/20+Q^5/30)\n\nThe program is cleanly separated into a number of subroutines. This was almost universal in FOCAL programs (and JOSS), as the line number scheme made such constructs easy to use. This program uses nine routines. The first, group 1, simply prints out the instructions using the {{code|T}}ype statement and sets the initial values for the run. The mass of fuel is not recorded directly, instead, it uses the current {{code|M}}ass and empty mass, {{code|N}}, so the remaining fuel is M-N and the lander runs out of fuel when M-N is 0. Also note the {{code|E}}rase at the end of line 1.20, which resets all the variable values.\n\nThe main game loop is driven by group 2. As the code \"falls\" through group 1 into group 2 during the first run, the initial values are printed out in the first two lines. Near the end of line 2.20, the user is {{code|A}}sked to input the burn rate as {{code|K}}, and then the loop timer is reset using {{code|S T{{=}}10}}. Line 2.70 tests the user's input against several possibilities, if it is over 200 or below 8 it types \"NOT POSSIBLE\" and a row of periods, and then loops back to ask the user to try again. If the value is between these values, it jumps forward to group 3. Note that the limited capabilities of FOCAL's {{code|IF}} command are evident here, in BASIC this could be reduced to a single {{code|IF K>200 OR K<8 THEN...}}\n\nGroup 3 first tests to see if the fuel has run out, and jumps to group 4 if it has. Then it tests if the 10-second period in {{code|T}} has expired and, if so, loops back to print everything out again, which has the side-effect of resetting T and S to 10. Line 3.40 tests to see if the amount of fuel burned this period, S*K, will reduce the mass of the vehicle as a whole, S*K-M, beyond the empty weight, N. If not, it moves on, if it will, it instead sets the loop timer to the amount of time the remaining fuel will burn, thus ending the loop early. In either case, it calls group 9 to update the velocity and position. It then loops over groups 7, 8 and 9 until the value of I converges.\n\nWhen the 10-second timer runs out, or it reaches the end due to the fuel test in line 3.10 or the altitude test in 7.10. In the latter cases, it will jump to group 4 and fall through to group 5, or jump to group 5 directly. Group 5 types the end-of-game results and then asks the user if they'd like to try again. If so, it jumps to 1.20 to clear out all values and print the headers again, if not if falls through to 5.98 and {{code|Q}}uits.\n\n==See also==\n*[[JOSS]], the Rand language that inspired FOCAL\n*[[MUMPS]], a data-manipulation language based on JOSS and FOCAL concepts\n\n==References==\n{{Reflist}}\n\n===Bibliography===\n* {{cite book\n |title=FOCAL Programming Manual \n |publisher=Digital Equipment Corporation \n |date=1968 \n |url=http://www.bitsavers.org/www.computer.museum.uq.edu.au/pdf/DEC-08-AJAB-D%20PDP-8-I%20FOCAL%20Programming%20Manual.pdf \n|ref=CITEREFManual1968\n}}\n* {{cite web\n |url=https://www.gamasutra.com/view/news/216469/A_basic_history_of_BASIC_on_its_50th_birthday.php\n |title=A basic history of BASIC on its 50th birthday\n |website=Gamasutra\n |date=1 May 2014\n |first=John |last=Szczepaniak\n |ref=harv\n}}\n* {{cite interview\n |first=Kevin |last=Savetz\n |date=April 2013\n |title=Dave Ahl and Betsy Ahl\n |url=https://computingpioneers.com/index.php?title=Dave_Ahl_and_Betsy_Ahl\n |ref=harv\n}}\n\n==External links==\n*[ftp://ftp.pdp8.net/software/games/focal/ FOCAL source code], FOCAL source for several programs, including Lunar Lander, Sumer Game, and others\n*[http://www.cs.uiowa.edu/~jones/pdp8/focal/ DEC's FOCAL 1969 Promotional Booklet]\n*[http://simh.trailing-edge.com/ The Computer History Simulation Project (Focal is available as a free download here)]\n*ftp://www.cozx.com/pub/langs/focal.tar.gz C-source version that runs under several operating systems, including Linux\n*[http://www.catb.org/retro the C-source for a modern DOS version suitable for teaching]  \n*[https://web.archive.org/web/20110525101809/http://www.libex.ru/detail/book91959.html Abramov V.A. Dialogue language FOCAL] (in Russian) {{ISBN|5-06-001785-0}}\n*[https://web.archive.org/web/20080626062957/http://www.vntb.ru/kniga255.html Osetinsky L.G. FOCAL for mini-computers] (in Russian) {{ISBN|5-217-00323-5}}\n*[http://samlib.ru/u/uirh/kn_o_foc.shtml \u0424\u043e\u043a\u0430\u043b \u0441\u043d\u0430\u0440\u0443\u0436\u0438 \u0438 \u0438\u0437\u043d\u0443\u0442\u0440\u0438. (\u043f\u0438\u0448\u0435\u0442\u0441\u044f)]&nbsp;\u2014 FOCAL outside and inside. (in progress) (in Russian)\n*[http://samlib.ru/editors/u/uirh/foc_hlp.shtml \u0424\u0430\u0439\u043b \u0441\u043f\u0440\u0430\u0432\u043a\u0438 \u043a \u0444\u043e\u043a\u0430\u043b\u0443-1\u0431]&nbsp;\u2014 Help file for FOCAL-1B (in Russian)\n\n[[Category:JOSS programming language family]]\n[[Category:Digital Equipment Corporation]]\n", "name_user": "Maury Markowitz", "label": "safe", "comment": "\u2192\u200eLibrary commands", "url_page": "//en.wikipedia.org/wiki/FOCAL_(programming_language)"}
